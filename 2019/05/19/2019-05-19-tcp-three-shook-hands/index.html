<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>TCP三次握手与四次挥手 - ddmcc</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="ddmcc"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="ddmcc"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="TCP是什么？TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。"><meta property="og:type" content="article"><meta property="og:title" content="TCP三次握手与四次挥手"><meta property="og:url" content="http://example.com/2019/05/19/2019-05-19-tcp-three-shook-hands/"><meta property="og:site_name" content="ddmcc"><meta property="og:description" content="TCP是什么？TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://ddmcc-1255635056.file.myqcloud.com/7a1f33b7-64b9-40ab-aef3-f15d5dde6eeb.png"><meta property="og:image" content="https://ddmcc-1255635056.file.myqcloud.com/47ff885b-f44c-44e1-a88c-638d5e46f4a3.png"><meta property="og:image" content="https://ddmcc-1255635056.file.myqcloud.com/9701ed1f-e077-4e19-8fd8-0627d91c602e.png"><meta property="article:published_time" content="2019-05-19T13:55:55.000Z"><meta property="article:modified_time" content="2023-04-15T14:41:11.174Z"><meta property="article:author" content="jiangrz"><meta property="article:tag" content="TCP"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://ddmcc-1255635056.file.myqcloud.com/7a1f33b7-64b9-40ab-aef3-f15d5dde6eeb.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2019/05/19/2019-05-19-tcp-three-shook-hands/"},"headline":"TCP三次握手与四次挥手","image":["https://ddmcc-1255635056.file.myqcloud.com/7a1f33b7-64b9-40ab-aef3-f15d5dde6eeb.png","https://ddmcc-1255635056.file.myqcloud.com/47ff885b-f44c-44e1-a88c-638d5e46f4a3.png","https://ddmcc-1255635056.file.myqcloud.com/9701ed1f-e077-4e19-8fd8-0627d91c602e.png"],"datePublished":"2019-05-19T13:55:55.000Z","dateModified":"2023-04-15T14:41:11.174Z","author":{"@type":"Person","name":"jiangrz"},"publisher":{"@type":"Organization","name":"ddmcc","logo":{"@type":"ImageObject","url":{"text":"jiangrz"}}},"description":"TCP是什么？TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。"}</script><link rel="canonical" href="http://example.com/2019/05/19/2019-05-19-tcp-three-shook-hands/"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.1.1"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">jiangrz</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="GitHub" href="https://github.com/ddmcc/ddmcc.github.io">GitHub</a><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ddmcc/ddmcc.github.io"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-05-19T13:55:55.000Z" title="2019/5/19 21:55:55">2019-05-19</time>发表</span><span class="level-item"><time dateTime="2023-04-15T14:41:11.174Z" title="2023/4/15 22:41:11">2023-04-15</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">网络协议</a></span></div></div><h1 class="title is-3 is-size-4-mobile">TCP三次握手与四次挥手</h1><div class="content"><h2 id="TCP是什么？"><a href="#TCP是什么？" class="headerlink" title="TCP是什么？"></a>TCP是什么？</h2><p>TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。</p>
<span id="more"></span>

<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p><img src="https://ddmcc-1255635056.file.myqcloud.com/7a1f33b7-64b9-40ab-aef3-f15d5dde6eeb.png" alt="markdown"></p>
<h3 id="TCP使用三次握手建立一个连接："><a href="#TCP使用三次握手建立一个连接：" class="headerlink" title="TCP使用三次握手建立一个连接："></a>TCP使用三次握手建立一个连接：</h3><p>第一次握手：客户端发送SYN=x包至服务器，并进入SYN_SENT状态，等待服务器确认</p>
<p>第二次握手：服务器收到客户端的SYN包，发送一个ACK=x+1，同时发送自己的SYN=y，此时服务器进入SYN_RCVD状态</p>
<p>第三次握手：客户端接收到服务器发送的SYN(y)+ACK(x+1)后，进入ESTABLISHED状态，并发送服务器SYN包的确认ACK(y+1)，服务器接收到客户端ACK(y+1)后，进入ESTABLISHED状态</p>
<p>当客户端和服务器都进入ESTABLISHED状态后，客户端和服务器之间就可以开始双向传递数据了</p>
<h3 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h3><p>在谢希仁著《计算机网络》书中同时举了一个例子，如下：</p>
<p>“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”</p>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p><img src="https://ddmcc-1255635056.file.myqcloud.com/47ff885b-f44c-44e1-a88c-638d5e46f4a3.png" alt="markdown"></p>
<h3 id="TCP使用四次挥手关闭一个连接："><a href="#TCP使用四次挥手关闭一个连接：" class="headerlink" title="TCP使用四次挥手关闭一个连接："></a>TCP使用四次挥手关闭一个连接：</h3><p>第一次挥手：主动关闭方发送一个FIN并进入FIN_WAIT1状态</p>
<p>第二次挥手：被动关闭方接收到主动关闭方发送的FIN并发送ACK，此时被动关闭方进入CLOSE_WAIT状态；主动关闭方收到被动关闭方的ACK后，进入FIN_WAIT2状态</p>
<p>第三次挥手：被动关闭方发送一个FIN并进入LAST_ACK状态</p>
<p>第四次挥手：主动关闭方收到被动关闭方发送的FIN并发送ACK，此时主动关闭方进入TIME_WAIT状态，经过2MSL时间后关闭连接；被动关闭方收到主动关闭方的ACK后，关闭连接</p>
<h3 id="为什么要四次分手"><a href="#为什么要四次分手" class="headerlink" title="为什么要四次分手"></a>为什么要四次分手</h3><p>那四次分手又是为何呢？TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。如果要正确的理解四次分手的原理，就需要了解四次分手过程中的状态变化。</p>
<ul>
<li><p><strong>FIN_WAIT_1:</strong> 这个状态要好好解释一下，其实FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即进入到FIN_WAIT_1状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1状态一般是比较难见到的，而FIN_WAIT_2状态还有时常常可以用netstat看到。（主动方）</p>
</li>
<li><p><strong>FIN_WAIT_2:</strong> 上面已经详细解释了这种状态，实际上FIN_WAIT_2状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据需要传送给你(ACK信息)，稍后再关闭连接。（主动方）</p>
</li>
<li><p><strong>CLOSE_WAIT</strong> 这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方close一个SOCKET后发送FIN报文给自己，你系统毫无疑问地会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以 close这个SOCKET，发送FIN报文给对方，也即关闭连接。所以你在CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接。（被动方）</p>
</li>
<li><p><strong>LAST_ACK:</strong> 这个状态还是比较容易好理解的，它是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了。（被动方）</p>
</li>
<li><p><strong>TIME_WAIT:</strong> 表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果FINWAIT1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。（主动方）</p>
</li>
<li><p><strong>CLOSED:</strong> 表示连接中断。</p>
</li>
</ul>
<p><img src="https://ddmcc-1255635056.file.myqcloud.com/9701ed1f-e077-4e19-8fd8-0627d91c602e.png" alt="markdown"></p>
<h2 id="HTTP连接"><a href="#HTTP连接" class="headerlink" title="HTTP连接"></a>HTTP连接</h2><p>HTTP协议即超文本传送协议(Hypertext Transfer Protocol )，是Web联网的基础，也是手机联网常用的协议之一，HTTP协议是建立在TCP协议之上的一种应用。<br>HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。从建立连接到关闭连接的过程称为“一次连接”。<br>1）在HTTP 1.0中，客户端的每次请求都要求建立一次单独的连接，在处理完本次请求后，就自动释放连接。</p>
<p>2）在HTTP 1.1中则可以在一次连接中处理多个请求，并且多个请求可以重叠进行，不需要等待一个请求结束后再发送下一个请求。</p>
<p>由于HTTP在每次请求结束后都会主动释放连接，因此HTTP连接是一种“短连接”，要保持客户端程序的在线状态，需要不断地向服务器发起连接请求。通常 的做法是即时不需要获得任何数据，客户端也保持每隔一段固定的时间向服务器发送一次“保持连接”的请求，服务器在收到该请求后对客户端进行回复，表明知道 客户端“在线”。若服务器长时间无法收到客户端的请求，则认为客户端“下线”，若客户端长时间无法收到服务器的回复，则认为网络已经断开。</p>
<h2 id="SOCKET原理"><a href="#SOCKET原理" class="headerlink" title="SOCKET原理"></a>SOCKET原理</h2><h3 id="套接字（socket）概念"><a href="#套接字（socket）概念" class="headerlink" title="套接字（socket）概念"></a>套接字（socket）概念</h3><p>套接字（socket）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。<br>应用层通过传输层进行数据通信时，TCP会遇到同时为多个应用程序进程提供并发服务的问题。多个TCP连接或多个应用程序进程可能需要通过同一个 TCP协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP／IP协议交互提供了套接字(Socket)接口。<br>传输层屏蔽了低层的实现过程，只抽象成给上层应用层使用的接口，这接口就是Socket。</p>
<h3 id="建立socket连接"><a href="#建立socket连接" class="headerlink" title="建立socket连接"></a>建立socket连接</h3><p>建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket ，另一个运行于服务器端，称为ServerSocket 。<br>套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。<br>服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。<br>客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。<br>连接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发 给客户端，一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。</p>
<h3 id="SOCKET连接与TCP连接"><a href="#SOCKET连接与TCP连接" class="headerlink" title="SOCKET连接与TCP连接"></a>SOCKET连接与TCP连接</h3><p>创建Socket连接时，可以指定使用的传输层协议，Socket可以支持不同的传输层协议（TCP或UDP），当使用TCP协议进行连接时，该Socket连接就是一个TCP连接。</p>
<h3 id="Socket连接与HTTP连接"><a href="#Socket连接与HTTP连接" class="headerlink" title="Socket连接与HTTP连接"></a>Socket连接与HTTP连接</h3><p>由于通常情况下Socket连接就是TCP连接，因此Socket连接一旦建立，通信双方即可开始相互发送数据内容，直到双方连接断开。但在实际网 络应用中，客户端到服务器之间的通信往往需要穿越多个中间节点，例如路由器、网关、防火墙等，大部分防火墙默认会关闭长时间处于非活跃状态的连接而导致 Socket 连接断连，因此需要通过轮询告诉网络，该连接处于活跃状态。<br>而HTTP连接使用的是“请求—响应”的方式，不仅在请求时需要先建立连接，而且需要客户端向服务器发出请求后，服务器端才能回复数据。<br>很多情况下，需要服务器端主动向客户端推送数据，保持客户端与服务器数据的实时与同步。此时若双方建立的是Socket连接，服务器就可以直接将数 据传送给客户端；若双方建立的是HTTP连接，则服务器需要等到客户端发送一次请求后才能将数据传回给客户端，因此，客户端定时向服务器端发送连接请求， 不仅可以保持在线，同时也是在“询问”服务器是否有新的数据，如果有就将数据传给客户端。</p>
<h2 id="转自"><a href="#转自" class="headerlink" title="转自"></a>转自</h2><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/a19881029/article/details/30241561" title="TCP三次握手/四次挥手">TCP三次握手/四次挥手</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/jawil/blog/issues/14" title="通俗大白话来理解TCP协议的三次握手和四次分手">通俗大白话来理解TCP协议的三次握手和四次分手</a></li>
</ul>
</div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/TCP/">TCP</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2019/05/21/2019-05-21-factory-method-pattern/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">设计模式之工厂方法模式</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2019/05/15/2019-05-14-automatic-continuous-ntegration/"><span class="level-item">github+阿里云容器镜像服务+jenkins自动化持续部署</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "51298693d4dce87be9b3467717ef3a72",
            repo: "ddmcc.github.io",
            owner: "ddmcc",
            clientID: "dae41ffb8c8e11287ad0",
            clientSecret: "2e2acba40e8060cbac419bae13b068ab92a539ab",
            admin: ["ddmcc"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 20,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            language: "zh-CN",
        })
        gitalk.render('comment-container')</script></div></div></div><!--!--><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen  order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#TCP是什么？"><span class="level-left"><span class="level-item">1</span><span class="level-item">TCP是什么？</span></span></a></li><li><a class="level is-mobile" href="#三次握手"><span class="level-left"><span class="level-item">2</span><span class="level-item">三次握手</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#TCP使用三次握手建立一个连接："><span class="level-left"><span class="level-item">2.1</span><span class="level-item">TCP使用三次握手建立一个连接：</span></span></a></li><li><a class="level is-mobile" href="#为什么要三次握手"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">为什么要三次握手</span></span></a></li></ul></li><li><a class="level is-mobile" href="#四次挥手"><span class="level-left"><span class="level-item">3</span><span class="level-item">四次挥手</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#TCP使用四次挥手关闭一个连接："><span class="level-left"><span class="level-item">3.1</span><span class="level-item">TCP使用四次挥手关闭一个连接：</span></span></a></li><li><a class="level is-mobile" href="#为什么要四次分手"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">为什么要四次分手</span></span></a></li></ul></li><li><a class="level is-mobile" href="#HTTP连接"><span class="level-left"><span class="level-item">4</span><span class="level-item">HTTP连接</span></span></a></li><li><a class="level is-mobile" href="#SOCKET原理"><span class="level-left"><span class="level-item">5</span><span class="level-item">SOCKET原理</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#套接字（socket）概念"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">套接字（socket）概念</span></span></a></li><li><a class="level is-mobile" href="#建立socket连接"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">建立socket连接</span></span></a></li><li><a class="level is-mobile" href="#SOCKET连接与TCP连接"><span class="level-left"><span class="level-item">5.3</span><span class="level-item">SOCKET连接与TCP连接</span></span></a></li><li><a class="level is-mobile" href="#Socket连接与HTTP连接"><span class="level-left"><span class="level-item">5.4</span><span class="level-item">Socket连接与HTTP连接</span></span></a></li></ul></li><li><a class="level is-mobile" href="#转自"><span class="level-left"><span class="level-item">6</span><span class="level-item">转自</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-07-06T07:34:00.000Z">2023-07-06</time></p><p class="title"><a href="/2023/07/06/2023-07-06-feign-integrates-ribbon/">feign基于ribbon实现负载均衡</a></p><p class="categories"><a href="/categories/Spring-Cloud/">Spring Cloud</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-05-29T07:34:00.000Z">2023-05-29</time></p><p class="title"><a href="/2023/05/29/2023-05-29-ribbon-components-and-integration-of-gateway/">openFeign整合ribbon实现负载均衡</a></p><p class="categories"><a href="/categories/Spring-Cloud/">Spring Cloud</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-05-29T07:34:00.000Z">2023-05-29</time></p><p class="title"><a href="/2023/05/29/2023-05-29-websocket-clusters/">websocket服务集群搭建与消息收发实现</a></p><p class="categories"><a href="/categories/websocket/">websocket</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-04-13T07:34:00.000Z">2023-04-13</time></p><p class="title"><a href="/2023/04/13/2023-04-13-how-feign-works/">OpenFeign的实现原理</a></p><p class="categories"><a href="/categories/Spring-Cloud/">Spring Cloud</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-04-01T07:34:00.000Z">2023-04-01</time></p><p class="title"><a href="/2023/04/01/2023-04-01-composite-pattern/">设计模式之组合模式</a></p><p class="categories"><a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></p></div></article></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">jiangrz</a><p class="is-size-7"><span>&copy; 2024 jiangrz</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent " target="_blank" rel="noopener" title="备案号：闽ICP备2023008580号-1" href="https://beian.miit.gov.cn">备案号：闽ICP备2023008580号-1</a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>