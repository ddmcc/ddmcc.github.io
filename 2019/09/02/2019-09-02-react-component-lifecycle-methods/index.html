<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>React组件生命周期 - ddmcc</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="ddmcc"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="ddmcc"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="React组件的一生主要分为四个阶段分别为初始化（Initialization），挂载（Mounting），更新（Updation），卸载（Unmounting）， 下面介绍挂载和更新的一些方法。"><meta property="og:type" content="article"><meta property="og:title" content="React组件生命周期"><meta property="og:url" content="http://example.com/2019/09/02/2019-09-02-react-component-lifecycle-methods/"><meta property="og:site_name" content="ddmcc"><meta property="og:description" content="React组件的一生主要分为四个阶段分别为初始化（Initialization），挂载（Mounting），更新（Updation），卸载（Unmounting）， 下面介绍挂载和更新的一些方法。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://ddmcc-1255635056.file.myqcloud.com/f9d08583-fb5b-413f-82b0-9bd462cff551.png"><meta property="og:image" content="https://ddmcc-1255635056.file.myqcloud.com/ab61714e-cb0e-429b-82ed-e5f03eff57f9.png"><meta property="og:image" content="https://ddmcc-1255635056.file.myqcloud.com/3b8e2d83-7d94-4461-b053-c8a71435bb65.png"><meta property="article:published_time" content="2019-09-02T15:25:18.000Z"><meta property="article:modified_time" content="2023-04-15T14:35:19.965Z"><meta property="article:author" content="jiangrz"><meta property="article:tag" content="react"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://ddmcc-1255635056.file.myqcloud.com/f9d08583-fb5b-413f-82b0-9bd462cff551.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2019/09/02/2019-09-02-react-component-lifecycle-methods/"},"headline":"React组件生命周期","image":["https://ddmcc-1255635056.file.myqcloud.com/f9d08583-fb5b-413f-82b0-9bd462cff551.png","https://ddmcc-1255635056.file.myqcloud.com/ab61714e-cb0e-429b-82ed-e5f03eff57f9.png","https://ddmcc-1255635056.file.myqcloud.com/3b8e2d83-7d94-4461-b053-c8a71435bb65.png"],"datePublished":"2019-09-02T15:25:18.000Z","dateModified":"2023-04-15T14:35:19.965Z","author":{"@type":"Person","name":"jiangrz"},"publisher":{"@type":"Organization","name":"ddmcc","logo":{"@type":"ImageObject","url":{"text":"jiangrz"}}},"description":"React组件的一生主要分为四个阶段分别为初始化（Initialization），挂载（Mounting），更新（Updation），卸载（Unmounting）， 下面介绍挂载和更新的一些方法。"}</script><link rel="canonical" href="http://example.com/2019/09/02/2019-09-02-react-component-lifecycle-methods/"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.1.1"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">jiangrz</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="GitHub" href="https://github.com/ddmcc/ddmcc.github.io">GitHub</a><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ddmcc/ddmcc.github.io"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-09-02T15:25:18.000Z" title="2019/9/2 23:25:18">2019-09-02</time>发表</span><span class="level-item"><time dateTime="2023-04-15T14:35:19.965Z" title="2023/4/15 22:35:19">2023-04-15</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></span></div></div><h1 class="title is-3 is-size-4-mobile">React组件生命周期</h1><div class="content"><p> 　　React组件的一生主要分为四个阶段分别为初始化（<code>Initialization</code>），挂载（<code>Mounting</code>），更新（<code>Updation</code>），卸载（<code>Unmounting</code>），<br> 下面介绍挂载和更新的一些方法。</p>
<span id="more"></span>

<h2 id="16-3之前"><a href="#16-3之前" class="headerlink" title="16.3之前"></a>16.3之前</h2><p><img src="https://ddmcc-1255635056.file.myqcloud.com/f9d08583-fb5b-413f-82b0-9bd462cff551.png" alt="markdown"></p>
<hr>
<h4 id="挂载阶段"><a href="#挂载阶段" class="headerlink" title="挂载阶段"></a>挂载阶段</h4><p> 　　挂载是指组件渲染并构造dom元素，然后将元素插入到页面的过程， <strong>这是一个从无到有的过程</strong> 。在这个过程中主要有以下几个方法：</p>
<ul>
<li>componentWillMount</li>
</ul>
<p>它会在组件渲染之前执行，在此方法之后，组件将渲染挂载，在组件的整个生命周期中，这个方法只会被执行一次，并且是服务端渲染唯一会调用的生命周期函数。<del>所以可以在此方法中做一些初始化的工作。</del></p>
<ul>
<li>render</li>
</ul>
<p>将组件渲染到页面中。它是一个<code>纯方法</code>，输出由输入决定</p>
<ul>
<li>componentDidMount</li>
</ul>
<p>此方法在生命周期中也只会执行一次，并且在组件挂载之后。在此方法中，可以获取到页面的dom节点。子组件的方法会在父组件之前调用</p>
<h4 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h4><p> 　　更新阶段是指调用setState或props改变而触发，或者调用<code>forceUpdate</code>来重新渲染组件并把组建的变化显示到DOM元素的过程。<br> <strong>这是一个变化的过程</strong></p>
<ul>
<li><p><strong>1,当通过调用setState更新状态触发</strong></p>
<ul>
<li>shouldComponentUpdate  此方法在收到新的props或者状态更新的过程中会被调用。见名知意，此方法可以控制组件是否要被重新渲染。方法返回true或false，当返回false时，组件不会被渲染。默认返回为true</li>
<li>componentWillUpdate此方法将在<code>shouldComponentUpdate</code>返回为true后被调用，类似<code>componentWillMount</code>，只不过它是在每次被重新渲染的时候都会被调用一次</li>
<li>render 同上</li>
<li>componentDidUpdate当组件被更新到DOM之后会被触发</li>
</ul>
</li>
<li><p><strong>2,父组件传入新的props</strong></p>
<ul>
<li><p>componentWillReceiveProps(nextProps)</p>
<p>当组件收到新的props会被触发，在首次渲染不会被调用。可以判断是否要根据父类传入新的props而要更改state，在此方法中调用setState不会重复渲染</p>
</li>
<li><p>shouldComponentUpdate</p>
<p>同上</p>
</li>
<li><p>componentWillUpdate</p>
<p>同上</p>
</li>
<li><p>render</p>
<p>同上</p>
</li>
<li><p>componentDidUpdate</p>
<p>同上</p>
</li>
</ul>
</li>
<li><p><strong>3,调用forceUpdate</strong></p>
<p>　　当不想通过state或props进行改变触发重新渲染时，可以调用forceUpdate，此操作会跳过该组件的 <code>shouldComponentUpdate</code>。但其子组件会触发正常的生命周期方法，包括<code>shouldComponentUpdate</code>方法。<br>通常不推荐使用该方法。</p>
</li>
</ul>
<h2 id="16-3版本"><a href="#16-3版本" class="headerlink" title="16.3版本"></a>16.3版本</h2><p> 　　在16.3中新增<code>static getDerivedStateFromProps(nextProps, prevState)</code>和<code>getSnapshotBeforeUpdate(prevProps, prevState)</code>，同时废弃了<code>componentWillMount</code>，<code>componentWillUpdate</code>，<code>componentWillReceiveProps</code>三个方法。<br> 先说为什么要废弃这三个在渲染之前的方法</p>
<p> 　　在React v16中发布了React Fiber，简单说一下Fiber</p>
<blockquote>
<p>在现有React中，更新过程是同步的，这可能会导致性能问题。在更新的过程中要做很多事情，比如调用各个组件的生命周期函数，计算和比对Virtual DOM，最后更新DOM树，这整个过程是同步进行的。</p>
<p>Fiber就是把所有任务分成一片一片，每当执行完一片，就会给其他任务执行的机会（感觉可以看成线程竞争cpu时间片😄），所以有可能当一个更新任务还没完成，就被其它优先级高的任务给中断了。<br>重点是被中断的任务不是在中断的地方接着执行，它是重新开始的…重新开始…</p>
<p>Fiber分为两个阶段，第一个阶段允许被打断，而第二阶段则不允许。以render为界，可以被打断的生命周期函数就有</p>
<ul>
<li>componentWillMount</li>
<li>componentWillReceiveProps</li>
<li>shouldComponentUpdate</li>
<li>componentWillUpdate</li>
<li>render</li>
</ul>
</blockquote>
<p> 　　<strong>所以如果在<code>componentWillMount</code>和<code>componentWillUpdate</code>做一些后台数据的获取或者定时器的初始化等的工作，将不再适合，因为这些方法有可能会被执行多次</strong>。官方为了不让大家在上面的方法中继续做不正确的事情，<br> 干脆把这几个方法给废弃了，并推出了新的方法<code>getDerivedStateFromProps</code>，如果之前在废弃的方法中的实现比较纯，那么直接移到新的方法中即可。它是一个静态方法，不能使用this，结果只由输入去改变，<strong>返回的结果直接传给setState</strong>。<br> <strong>如果是要去后台获取数据或者初始化的工作则可以移到<code>componentWillMount</code>和<code>componentWillUpdate</code>方法中</strong>。这两个方法不会有被执行多次的可能。</p>
<hr>
<p><img src="https://ddmcc-1255635056.file.myqcloud.com/ab61714e-cb0e-429b-82ed-e5f03eff57f9.png" alt="markdown"></p>
<hr>
<p> 图来源于<a target="_blank" rel="noopener" href="http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/">http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/</a></p>
<h4 id="挂载阶段-1"><a href="#挂载阶段-1" class="headerlink" title="挂载阶段"></a>挂载阶段</h4><ul>
<li>getDerivedStateFromProps <code>static getDerivedStateFromProps(nextProps, prevState)</code> 这是一个静态的方法，会传入新的props和原来的状态值。在调用 render 方法之前调用，它应返回一个对象来更新 state，如果返回 null 则不会更新内容。<br> 官方文档也说了这个方法适用于state的值在任何时候都取决于props，如果要做 <strong>有副作用的操作则应使用DidMounting，DidUpdate或在prop更改时“重置”某些state则可以考虑使用受控的组件</strong>  如图此方法也可能会被暂停，中断或重新开始，因为处于<code>Render 阶段</code></li>
<li>render  方法也可能会被暂停，中断或重新开始</li>
<li>componentDidMount  同上</li>
</ul>
<h4 id="更新阶段-1"><a href="#更新阶段-1" class="headerlink" title="更新阶段"></a>更新阶段</h4><ul>
<li><p><strong>1,调用setState更新状态触发</strong></p>
<ul>
<li><p>shouldComponentUpdate</p>
<p>  调用<code>setState</code>触发的渲染并不会调用getDerivedStateFromProps，而是直接到了<code>shouldComponentUpdate</code>。<strong>需要注意的是shouldComponentUpdate也有执行多次的可能</strong></p>
</li>
<li><p>render</p>
<p>  同挂载阶段，也可能多次执行</p>
</li>
<li><p>getSnapshotBeforeUpdate(prevProps, prevState)</p>
<p>  这也是在V16.3中新加入的方法，只有在更新阶段，<code>render</code>方法和真正DOM被改变之间执行，如图这时可以读取dom，此方法不会被中止或重新开始。<strong>方法返回的值会在<code>componentDidUpdate</code>方法的第三个参数传入</strong></p>
</li>
</ul>
<blockquote>
<p>componentDidUpdate(prevProps, prevState, snapshot)</p>
</blockquote>
<ul>
<li>componentDidUpdate 同上</li>
</ul>
</li>
<li><p><strong>2,父组件传入新的props</strong></p>
<ul>
<li>getDerivedStateFromProps  在更新阶段的<code>setState</code>方法而触发的重新渲染会被调用，解释如上。**需要注意的是，此方法也在“纯净不包含副作用”阶段，所以可能会被执行多次。</li>
<li>shouldComponentUpdate   同上</li>
<li>render  同上</li>
<li>componentDidUpdate  同上</li>
</ul>
</li>
<li><p><strong>3,调用forceUpdate</strong></p>
<p>  此过程和16.3之前一样会直接到render方法</p>
</li>
</ul>
<h2 id="16-4"><a href="#16-4" class="headerlink" title="^16.4"></a>^16.4</h2><p> 　　在16.3中新加入的<code>getDerivedStateFromProps</code>方法只有在挂载和由<code>setState</code>引起的Updating才会被执行，这可能会给开发人员带来困扰，父组件传入新的props和forceUpdate并不会Updating。</p>
<p> 　　**在16.4中，React官方改正了这一点，无论是挂在阶段或是任何动作引起的Updating都会触发<code>getDerivedStateFromProps</code>**。</p>
<p> 　　所以16.4的生命周期方法如下图：</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://ddmcc-1255635056.file.myqcloud.com/3b8e2d83-7d94-4461-b053-c8a71435bb65.png" alt="markdown"></h2><p> 　　解释：略</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> 　　用静态函数getDerivedStateFromProps来取代被deprecate的几个生命周期函数，就是强制开发者在render之前只做无副作用的操作，而且能做的操作局限在根据props和state决定新的state，因为在render阶段生命周期方法可能会被执行多次。<strong>废弃的方法会在17版本中删除</strong></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/react-component.html">https://zh-hans.reactjs.org/docs/react-component.html</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/38030418">React v16.3之后的组件生命周期函数</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/26027085">React Fiber是什么</a></p>
<p><a target="_blank" rel="noopener" href="http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/">http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/</a></p>
</div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/react/">react</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2019/09/15/2019-09-15-template-method-pattern/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">设计模式之模板方法模式</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2019/08/27/2019-08-27-facade-pattern/"><span class="level-item">设计模式之外观模式</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "1dc19daa5b9912a528002f02b87b4b14",
            repo: "ddmcc.github.io",
            owner: "ddmcc",
            clientID: "dae41ffb8c8e11287ad0",
            clientSecret: "2e2acba40e8060cbac419bae13b068ab92a539ab",
            admin: ["ddmcc"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 20,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            language: "zh-CN",
        })
        gitalk.render('comment-container')</script></div></div></div><!--!--><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen  order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#16-3之前"><span class="level-left"><span class="level-item">1</span><span class="level-item">16.3之前</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#挂载阶段"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">挂载阶段</span></span></a></li><li><a class="level is-mobile" href="#更新阶段"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">更新阶段</span></span></a></li></ul></li><li><a class="level is-mobile" href="#16-3版本"><span class="level-left"><span class="level-item">2</span><span class="level-item">16.3版本</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#挂载阶段-1"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">挂载阶段</span></span></a></li><li><a class="level is-mobile" href="#更新阶段-1"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">更新阶段</span></span></a></li></ul></li><li><a class="level is-mobile" href="#16-4"><span class="level-left"><span class="level-item">3</span><span class="level-item">^16.4</span></span></a></li><li><a class="level is-mobile" href="#"><span class="level-left"><span class="level-item">4</span><span class="level-item"> </span></span></a></li><li><a class="level is-mobile" href="#总结"><span class="level-left"><span class="level-item">5</span><span class="level-item">总结</span></span></a></li><li><a class="level is-mobile" href="#参考"><span class="level-left"><span class="level-item">6</span><span class="level-item">参考</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-07-06T07:34:00.000Z">2023-07-06</time></p><p class="title"><a href="/2023/07/06/2023-07-06-feign-integrates-ribbon/">feign基于ribbon实现负载均衡</a></p><p class="categories"><a href="/categories/Spring-Cloud/">Spring Cloud</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-05-29T07:34:00.000Z">2023-05-29</time></p><p class="title"><a href="/2023/05/29/2023-05-29-ribbon-components-and-integration-of-gateway/">openFeign整合ribbon实现负载均衡</a></p><p class="categories"><a href="/categories/Spring-Cloud/">Spring Cloud</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-05-29T07:34:00.000Z">2023-05-29</time></p><p class="title"><a href="/2023/05/29/2023-05-29-websocket-clusters/">websocket服务集群搭建与消息收发实现</a></p><p class="categories"><a href="/categories/websocket/">websocket</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-04-13T07:34:00.000Z">2023-04-13</time></p><p class="title"><a href="/2023/04/13/2023-04-13-how-feign-works/">OpenFeign的实现原理</a></p><p class="categories"><a href="/categories/Spring-Cloud/">Spring Cloud</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-04-01T07:34:00.000Z">2023-04-01</time></p><p class="title"><a href="/2023/04/01/2023-04-01-composite-pattern/">设计模式之组合模式</a></p><p class="categories"><a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></p></div></article></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">jiangrz</a><p class="is-size-7"><span>&copy; 2024 jiangrz</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent " target="_blank" rel="noopener" title="备案号：闽ICP备2023008580号-1" href="https://beian.miit.gov.cn">备案号：闽ICP备2023008580号-1</a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>