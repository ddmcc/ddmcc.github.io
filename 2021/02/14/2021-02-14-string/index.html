<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>扒一扒String - ddmcc</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="ddmcc"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="ddmcc"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="String不可变性什么是不可变对象       众所周知，String 对象是不可变的。那么什么是不可变对象呢？在 Java教程 中定义：如果一个对象在构造后状态无法改变，则该对象被视为不可变。"><meta property="og:type" content="article"><meta property="og:title" content="扒一扒String"><meta property="og:url" content="http://example.com/2021/02/14/2021-02-14-string/"><meta property="og:site_name" content="ddmcc"><meta property="og:description" content="String不可变性什么是不可变对象       众所周知，String 对象是不可变的。那么什么是不可变对象呢？在 Java教程 中定义：如果一个对象在构造后状态无法改变，则该对象被视为不可变。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://ddmcc-1255635056.file.myqcloud.com/8d3094e8-4633-4c51-910d-e6583eaf13b0.png"><meta property="og:image" content="https://ddmcc-1255635056.file.myqcloud.com/28a6c330-391f-4512-8732-ad9d6b60d7d9.png"><meta property="og:image" content="https://ddmcc-1255635056.file.myqcloud.com/45b726c9-42c8-44dd-a8ae-2c81b3f8337d.png"><meta property="og:image" content="https://ddmcc-1255635056.file.myqcloud.com/202bf514-acd6-4e8d-b6d0-b86ea7abbec3.png"><meta property="og:image" content="https://ddmcc-1255635056.file.myqcloud.com/f7e18f4f-7636-4139-8c9e-0a842ab96d8b.png"><meta property="og:image" content="https://ddmcc-1255635056.file.myqcloud.com/0043e0ce-3a7e-49ae-8370-4d0fea6fd663.png"><meta property="og:image" content="https://ddmcc-1255635056.file.myqcloud.com/9962fb9b-6912-45b6-9528-3a3e34d33e7a.png"><meta property="article:published_time" content="2021-02-14T07:18:23.000Z"><meta property="article:modified_time" content="2023-04-15T14:26:11.896Z"><meta property="article:author" content="jiangrz"><meta property="article:tag" content="Java基础"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://ddmcc-1255635056.file.myqcloud.com/8d3094e8-4633-4c51-910d-e6583eaf13b0.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2021/02/14/2021-02-14-string/"},"headline":"扒一扒String","image":["https://ddmcc-1255635056.file.myqcloud.com/8d3094e8-4633-4c51-910d-e6583eaf13b0.png","https://ddmcc-1255635056.file.myqcloud.com/28a6c330-391f-4512-8732-ad9d6b60d7d9.png","https://ddmcc-1255635056.file.myqcloud.com/45b726c9-42c8-44dd-a8ae-2c81b3f8337d.png","https://ddmcc-1255635056.file.myqcloud.com/202bf514-acd6-4e8d-b6d0-b86ea7abbec3.png","https://ddmcc-1255635056.file.myqcloud.com/f7e18f4f-7636-4139-8c9e-0a842ab96d8b.png","https://ddmcc-1255635056.file.myqcloud.com/0043e0ce-3a7e-49ae-8370-4d0fea6fd663.png","https://ddmcc-1255635056.file.myqcloud.com/9962fb9b-6912-45b6-9528-3a3e34d33e7a.png"],"datePublished":"2021-02-14T07:18:23.000Z","dateModified":"2023-04-15T14:26:11.896Z","author":{"@type":"Person","name":"jiangrz"},"publisher":{"@type":"Organization","name":"ddmcc","logo":{"@type":"ImageObject","url":{"text":"jiangrz"}}},"description":"String不可变性什么是不可变对象       众所周知，String 对象是不可变的。那么什么是不可变对象呢？在 Java教程 中定义：如果一个对象在构造后状态无法改变，则该对象被视为不可变。"}</script><link rel="canonical" href="http://example.com/2021/02/14/2021-02-14-string/"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.1.1"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">jiangrz</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="GitHub" href="https://github.com/ddmcc/ddmcc.github.io">GitHub</a><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ddmcc/ddmcc.github.io"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-02-14T07:18:23.000Z" title="2021/2/14 15:18:23">2021-02-14</time>发表</span><span class="level-item"><time dateTime="2023-04-15T14:26:11.896Z" title="2023/4/15 22:26:11">2023-04-15</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a></span></div></div><h1 class="title is-3 is-size-4-mobile">扒一扒String</h1><div class="content"><h3 id="String不可变性"><a href="#String不可变性" class="headerlink" title="String不可变性"></a><strong>String不可变性</strong></h3><h4 id="什么是不可变对象"><a href="#什么是不可变对象" class="headerlink" title="什么是不可变对象"></a><strong>什么是不可变对象</strong></h4><p>       众所周知，<code>String</code> 对象是不可变的。那么什么是不可变对象呢？在 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/essential/concurrency/immutable.html">Java教程</a> 中定义：<strong>如果一个对象在构造后状态无法改变，则该对象被视为不可变。</strong></p>
<span id="more"></span>

<blockquote>
<p>不能改变状态的意思是，不能改变对象内的成员变量，包括基本数据类型的值不能改变，引用类型的变量不能指向其他的对象，引用类型指向的对象的状态也不能改变。</p>
</blockquote>
<h4 id="不可变对象的遵守策略（规则）"><a href="#不可变对象的遵守策略（规则）" class="headerlink" title="不可变对象的遵守策略（规则）"></a><strong>不可变对象的遵守策略（规则）</strong></h4><ul>
<li>类中所有字段都被 <code>final</code> 修饰，并且是私有的，也就是被 <code>private</code> 修饰。</li>
<li>不能提供修改字段或字段引用对象的 <code>setter</code> 方法。</li>
<li>不允许子类重写方法</li>
<li>如果实例字段包含对可变对象的引用，则不允许更改这些对象：<ul>
<li>不要提供修改可变对象的方法。</li>
<li>不要直接返回可变对象的引用。如有必要，可创建内部可变对象的副本，并返回可变对象的副本。</li>
</ul>
</li>
</ul>
<h4 id="String的不可变性"><a href="#String的不可变性" class="headerlink" title="String的不可变性"></a><strong>String的不可变性</strong></h4><p>定义一个字符串 <code>s</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">    System.out.println(s);</span><br><span class="line"></span><br><span class="line">    s = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">abcd</span><br><span class="line">abcdef</span><br></pre></td></tr></table></figure>

<p>首先创建一个对象 <code>s</code> ，并赋值为abcd，然后再赋值为abcdef。从输出结果可以看出s的值确实改变了，那么为什么还说String对象是不可变的呢？</p>
<p>其实 <code>s</code> 变量只是保存了对象的引用，该引用指向了堆中具体的对象。如下图：</p>
<p><img src="https://ddmcc-1255635056.file.myqcloud.com/8d3094e8-4633-4c51-910d-e6583eaf13b0.png"></p>
<p>然后又创建了一个新的对象abcdef， 而引用s重新指向了这个新的对象，原来的对象abcd还在内存中存在，并没有改变。如下图：</p>
<p><img src="https://ddmcc-1255635056.file.myqcloud.com/28a6c330-391f-4512-8732-ad9d6b60d7d9.png"></p>
<p>所以上面的代码仅仅改变了s的引用地址</p>
<h5 id="为什么String对象是不可变的？"><a href="#为什么String对象是不可变的？" class="headerlink" title="为什么String对象是不可变的？"></a><strong>为什么String对象是不可变的？</strong></h5><p>要理解String的不可变性，先看String类的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> hash; <span class="comment">// Default to 0</span></span><br></pre></td></tr></table></figure>

<p>通过源码可以发现：String类内部是用一个字符数组来维护值的，并且被申明为 <code>private final</code> ，也就是value字符数组在对象被构造后就不允许重新赋值了。并且类内部也没有提供可以修改value数组值的setter方法，<br>所以可以认为String对象是不可变的。</p>
<p>可能会发现String类还提供了很多方法可以修改字符串值的方法：<strong>substring</strong> , <strong>concat</strong> , <strong>replace</strong> , <strong>replaceAll</strong> 等等。</p>
<p>比如 <code>substring</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">    System.out.println(s.substring(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行后输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">abcd</span><br><span class="line">bcd</span><br></pre></td></tr></table></figure>

<p>可以看到s的值确实是变了。这解释起来也很容易，看 <code>substring</code> 方法实现就明白了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> beginIndex)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (beginIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StringIndexOutOfBoundsException</span>(beginIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">subLen</span> <span class="operator">=</span> value.length - beginIndex;</span><br><span class="line">    <span class="keyword">if</span> (subLen &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StringIndexOutOfBoundsException</span>(subLen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (beginIndex == <span class="number">0</span>) ? <span class="built_in">this</span> : <span class="keyword">new</span> <span class="title class_">String</span>(value, beginIndex, subLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码并不是去修改的 value 数组里的值，而是重新创建一个新的对象，并把新的对象引用赋值给s。其它修改字符串值的方法也都一样，都是创建新的对象返回。</p>
<h5 id="String的值真的不可变吗？"><a href="#String的值真的不可变吗？" class="headerlink" title="String的值真的不可变吗？"></a><strong>String的值真的不可变吗？</strong></h5><p>value变量是 <code>private final</code> 的，也就是初始化后不可修改。它是引用变量，虽然不能重新指向其它堆内存地址，但可以通过反射去修改堆里的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">    <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> String.class.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">    field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">char</span>[] chars = (<span class="type">char</span>[]) field.get(s);</span><br><span class="line">    chars[<span class="number">1</span>] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>输出结果为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a%cd</span><br></pre></td></tr></table></figure>

<p>这个反射的实例还可以说明一个问题：如果一个对象，他组合的其他对象的状态是可以改变的，那么这个对象很可能不是不可变对象。例如一个Car对象，它组合了一个Wheel对象，虽然这个Wheel对象声明成了private final 的，但是这个Wheel对象内部的状态可以改变， 那么就不能很好的保证Car对象不可变。</p>
<h3 id="JDK6与JDK7中String类实现的区别"><a href="#JDK6与JDK7中String类实现的区别" class="headerlink" title="JDK6与JDK7中String类实现的区别"></a><strong>JDK6与JDK7中String类实现的区别</strong></h3><h5 id="JDK-6"><a href="#JDK-6" class="headerlink" title="JDK 6"></a><strong>JDK 6</strong></h5><blockquote>
<p>String是通过字符数组实现的。在jdk 6 中，String类包含三个成员变量：char value[]， int offset，int count。他们分别用来存储真正的字符数组，数组的第一个位置索引以及字符串中包含的字符个数。</p>
</blockquote>
<p>下面是jdk1.6中的源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The offset is the first index of the storage that is used. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> offset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The count is the number of characters in the String. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// JDK 6</span></span><br><span class="line">    <span class="comment">// Package private constructor which shares value array for speed.</span></span><br><span class="line">    String(<span class="type">int</span> offset, <span class="type">int</span> count, <span class="type">char</span> value[]) &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.offset = offset;</span><br><span class="line">        <span class="built_in">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// substring</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> beginIndex, <span class="type">int</span> endIndex)</span> &#123;</span><br><span class="line">        <span class="comment">//check boundary</span></span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">new</span> <span class="title class_">String</span>(offset + beginIndex, endIndex - beginIndex, value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// concat</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">concat</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="number">0</span>, count + otherLen, buf);</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其它修改字符串的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>当调用substring,concat等方法的时候，会创建一个新的string对象，但是这个string的值仍然指向堆中的同一个字符数组。这两个对象中只有count和offset 的值是不同的</p>
<p><img src="https://ddmcc-1255635056.file.myqcloud.com/45b726c9-42c8-44dd-a8ae-2c81b3f8337d.png"></p>
<h5 id="JDK-6中的substring导致的问题"><a href="#JDK-6中的substring导致的问题" class="headerlink" title="JDK 6中的substring导致的问题"></a><strong>JDK 6中的substring导致的问题</strong></h5><p>如果你有一个很长很长的字符串，但是当你使用substring进行切割的时候你只需要很短的一段。这可能导致性能问题，因为你需要的只是一小段字符序列，但是你却引用了整个字符串（因为这个非常长的字符数组一直在被引用，所以无法被回收，就可能导致内存泄露）。在JDK 6中，一般用以下方式来解决该问题，原理其实就是生成一个新的字符串并引用他。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = x.substring(x, y) + <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>内存泄露：在计算机科学中，内存泄漏指由于疏忽或错误造成程序未能释放已经不再使用的内存。 内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费。</p>
</blockquote>
<p>concat也同样有该问题，如果对象a只需要很小一段字符序列，对象b去拼接了很长的字符串，这就导致如果a对象没被回收，这个很长很长的字符数组就一直不会被释放。</p>
<h5 id="JDK-7"><a href="#JDK-7" class="headerlink" title="JDK 7"></a><strong>JDK 7</strong></h5><p>上面提到的问题，在jdk 7中得到解决。在jdk 7 中，substring，concat等方法会在堆内存中创建一个新的数组。</p>
<p><img src="https://ddmcc-1255635056.file.myqcloud.com/202bf514-acd6-4e8d-b6d0-b86ea7abbec3.png"></p>
<p>Java源码中关于这部分的主要代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> beginIndex, <span class="type">int</span> endIndex)</span> &#123;</span><br><span class="line">    <span class="comment">// check boundary</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">subLen</span> <span class="operator">=</span> endIndex - beginIndex;</span><br><span class="line">    <span class="keyword">return</span> ((beginIndex == <span class="number">0</span>) &amp;&amp; (endIndex == value.length)) ? <span class="built_in">this</span></span><br><span class="line">            : <span class="keyword">new</span> <span class="title class_">String</span>(value, beginIndex, subLen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(<span class="type">char</span> value[], <span class="type">int</span> offset, <span class="type">int</span> count)</span> &#123;</span><br><span class="line">     <span class="comment">// check boundary</span></span><br><span class="line">    <span class="built_in">this</span>.value = Arrays.copyOfRange(value, offset, offset+count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>以上是JDK 7中的subString方法，其使用new String创建了一个新字符串，避免对老字符串的引用。从而解决了内存泄露问题。</p>
<p>所以，如果你的生产环境中使用的JDK版本小于1.7，当你使用String的subString方法时一定要注意，避免内存泄露。</p>
<h3 id="编译器对String字符串拼接的优化"><a href="#编译器对String字符串拼接的优化" class="headerlink" title="编译器对String字符串拼接的优化"></a><strong>编译器对String字符串拼接的优化</strong></h3><ul>
<li>String s = “a” + “b”，编译器会进行常量折叠(因为两个都是编译期常量，编译期可知)，即变成 String s = “ab”</li>
</ul>
<p><img src="https://ddmcc-1255635056.file.myqcloud.com/f7e18f4f-7636-4139-8c9e-0a842ab96d8b.png" alt="markdown"></p>
<ul>
<li>对于能够进行优化的(String s = “a” + var 等)用 StringBuilder 的 append() 方法替代，最后调用 toString() 方法 (底层就是一个 new String())</li>
</ul>
<p><img src="https://ddmcc-1255635056.file.myqcloud.com/0043e0ce-3a7e-49ae-8370-4d0fea6fd663.png" alt="markdown"></p>
<h3 id="字符串拼接的几种方式和区别"><a href="#字符串拼接的几种方式和区别" class="headerlink" title="字符串拼接的几种方式和区别"></a><strong>字符串拼接的几种方式和区别</strong></h3><h5 id="字符串不变性与字符串拼接"><a href="#字符串不变性与字符串拼接" class="headerlink" title="字符串不变性与字符串拼接"></a><strong>字符串不变性与字符串拼接</strong></h5><p>其实，所有的所谓字符串拼接，都是重新生成了一个新的字符串。下面一段字符串拼接代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">s = s.concat(<span class="string">&quot;ef&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>其实最后我们得到的s已经是一个新的字符串了。如下图</p>
<p><img src="https://ddmcc-1255635056.file.myqcloud.com/9962fb9b-6912-45b6-9528-3a3e34d33e7a.png" alt="markdown"></p>
<p>s中保存的是一个重新创建出来的String对象的引用。</p>
<h5 id="1-使用-拼接字符串"><a href="#1-使用-拼接字符串" class="headerlink" title="1.使用 + 拼接字符串"></a><strong>1.使用 <code>+</code> 拼接字符串</strong></h5><p>在Java中，拼接字符串最简单的方式就是直接使用符号 <code>+</code> 来拼接。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> a + <span class="string">&quot;,&quot;</span> + b;</span><br></pre></td></tr></table></figure>

<p>其实使用 <code>+</code> 拼接字符串，只是Java提供的一个语法糖， 那么，我们就来解一解这个语法糖，看看他的内部原理到底是如何实现的。</p>
<p>上面代码经过反编译后如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>().append((String)a).append((String)<span class="string">&quot;,&quot;</span>).append((String)b).toString();</span><br></pre></td></tr></table></figure>

<p>通过查看反编译以后的代码，我们可以发现，原来字符串常量在拼接过程中，是将String转成了StringBuilder后，使用其append方法进行处理的。</p>
<p>那么也就是说，Java中的 <code>+</code> 对字符串的拼接，其实现原理是使用 <code>StringBuilder.append</code>。</p>
<h5 id="2-concat"><a href="#2-concat" class="headerlink" title="2.concat"></a><strong>2.concat</strong></h5><p>还可以使用String类中的方法concat方法来拼接字符串。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> a.concat(<span class="string">&quot;,&quot;</span>).concat(b);</span><br></pre></td></tr></table></figure>

<p>我们再来看一下concat方法的源代码，看一下这个方法又是如何实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">concat</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">otherLen</span> <span class="operator">=</span> str.length();</span><br><span class="line">    <span class="keyword">if</span> (otherLen == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> value.length;</span><br><span class="line">    <span class="type">char</span> buf[] = Arrays.copyOf(value, len + otherLen);</span><br><span class="line">    str.getChars(buf, len);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(buf, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码首先创建了一个字符数组，长度是已有字符串和待拼接字符串的长度之和，再把两个字符串的值复制到新的字符数组中，并使用这个字符数组创建一个新的String对象并返回。</p>
<p>通过源码我们也可以看到，经过concat方法，其实是new了一个新的String，这也就呼应到前面我们说的字符串的不变性问题上了。</p>
<h5 id="3-StringBuffer和StringBuilder"><a href="#3-StringBuffer和StringBuilder" class="headerlink" title="3.StringBuffer和StringBuilder"></a><strong>3.StringBuffer和StringBuilder</strong></h5><p>关于字符串，Java中除了定义了一个可以用来定义 <strong>字符串常量</strong> 的 <code>String</code> 类以外，还提供了可以用来定义 <strong>字符串变量</strong> 的 <code>StringBuffer</code>和 <code>StringBuilder</code> 类，它的对象是可以扩充和修改的。</p>
<p>使用 <code>StringBuffer</code> 和 <code>StringBuilder</code> 可以方便的对字符串进行拼接。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> buffer.append(<span class="string">&quot;,&quot;</span>).append(b).toString();</span><br><span class="line"></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> builder.append(<span class="string">&quot;,&quot;</span>).append(b).toString();</span><br></pre></td></tr></table></figure>


<p>接下来我们看看 <code>StringBuffer</code>和 <code>StringBuilder</code> 的实现原理。</p>
<p>和 <code>String</code> 类类似， <code>StringBuffer</code>和 <code>StringBuilder</code> 类也封装了一个字符数组，定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>[] value;</span><br></pre></td></tr></table></figure>

<p>其append源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> StringBuilder <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该类继承了AbstractStringBuilder类，看下其append方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> AbstractStringBuilder <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> appendNull();</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();</span><br><span class="line">    ensureCapacityInternal(count + len);</span><br><span class="line">    str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">    count += len;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>append会直接拷贝字符到内部的字符数组中，如果字符数组长度不够，会进行扩展。</p>
<p><code>StringBuffer</code> 和 <code>StringBuilder</code> 类似，最大的区别就是 <code>StringBuffer</code> 是线程安全的，看一下 <code>StringBuffer</code> 的append方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    toStringCache = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法使用 <code>synchronized</code> 进行声明，说明是一个线程安全的方法。而 <code>StringBuilder</code> 则不是线程安全的。</p>
<p>常用的字符串拼接方式有五种，分别是使用+、使用concat、使用StringBuilder、使用StringBuffer以及使用StringUtils.join。</p>
<p>由于字符串拼接过程中会创建新的对象，所以如果要在一个循环体中进行字符串拼接，就要考虑内存问题和效率问题。</p>
<p>因此，经过对比，我们发现，直接使用StringBuilder的方式是效率最高的。因为StringBuilder天生就是设计来定义可变字符串和字符串的变化操作的。</p>
<p>但是，还要强调的是：</p>
<p>1、如果不是在循环体中进行字符串拼接的话，直接使用+就好了。</p>
<p>2、如果在并发场景中进行字符串拼接的话，要使用StringBuffer来代替StringBuilder。</p>
<h3 id="switch对String的支持"><a href="#switch对String的支持" class="headerlink" title="switch对String的支持"></a><strong>switch对String的支持</strong></h3><p>Java 7中，switch的参数可以是String类型了。到目前为止switch支持这样几种数据类型：<code>byte</code> <code>short</code> <code>int</code> <code>char</code> <code>String</code></p>
<p>还是先上代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    <span class="keyword">switch</span> (str) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;hello&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;world&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对代码进行反编译：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    String s;</span><br><span class="line">    <span class="keyword">switch</span>((s = str).hashCode())</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">99162322</span>:</span><br><span class="line">        <span class="keyword">if</span>(s.equals(<span class="string">&quot;hello&quot;</span>))</span><br><span class="line">            System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">113318802</span>:</span><br><span class="line">        <span class="keyword">if</span>(s.equals(<span class="string">&quot;world&quot;</span>))</span><br><span class="line">            System.out.println(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>看到这个代码，你知道原来字符串的switch是通过equals()和hashCode()方法来实现的。记住，switch中只能使用整型，比如byte。short，char(ackii码是整型)以及int。还好hashCode()方法返回的是int，而不是long。通过这个很容易记住hashCode返回的是int这个事实。仔细看下可以发现，进行switch的实际是哈希值，然后通过使用equals方法比较进行安全检查，这个检查是必要的，因为哈希可能会发生碰撞。因此它的性能是不如使用枚举进行switch或者使用纯整数常量，但这也不是很差。因为Java编译器只增加了一个equals方法，如果你比较的是字符串字面量的话会非常快，比如”abc” ==”abc”。如果你把hashCode()方法的调用也考虑进来了，那么还会再多一次的调用开销，因为字符串一旦创建了，它就会把哈希值缓存起来。因此如果这个switch语句是用在一个循环里的，比如逐项处理某个值，或者游戏引擎循环地渲染屏幕，这里hashCode()方法的调用开销其实不会很大。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h3><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/essential/concurrency/imstrat.html">定义不可变对象的策略</a></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/336799824/answer/763164656">为什么String在java中是不可变的？</a></p>
</div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Java%E5%9F%BA%E7%A1%80/">Java基础</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/02/27/2021-02-27-length-limit-on-string/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">String字符串的长度限制</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/02/08/2021-02-08-boxing-unboxing/"><span class="level-item">自动拆箱与装箱</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "fbc5cec13a4537574e2b302e5b041f61",
            repo: "ddmcc.github.io",
            owner: "ddmcc",
            clientID: "dae41ffb8c8e11287ad0",
            clientSecret: "2e2acba40e8060cbac419bae13b068ab92a539ab",
            admin: ["ddmcc"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 20,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            language: "zh-CN",
        })
        gitalk.render('comment-container')</script></div></div></div><!--!--><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen  order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#String不可变性"><span class="level-left"><span class="level-item">1</span><span class="level-item">String不可变性</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#什么是不可变对象"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">什么是不可变对象</span></span></a></li><li><a class="level is-mobile" href="#不可变对象的遵守策略（规则）"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">不可变对象的遵守策略（规则）</span></span></a></li><li><a class="level is-mobile" href="#String的不可变性"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">String的不可变性</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#为什么String对象是不可变的？"><span class="level-left"><span class="level-item">1.3.1</span><span class="level-item">为什么String对象是不可变的？</span></span></a></li><li><a class="level is-mobile" href="#String的值真的不可变吗？"><span class="level-left"><span class="level-item">1.3.2</span><span class="level-item">String的值真的不可变吗？</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#JDK6与JDK7中String类实现的区别"><span class="level-left"><span class="level-item">2</span><span class="level-item">JDK6与JDK7中String类实现的区别</span></span></a><ul class="menu-list"><ul class="menu-list"><li><a class="level is-mobile" href="#JDK-6"><span class="level-left"><span class="level-item">2.1.1</span><span class="level-item">JDK 6</span></span></a></li><li><a class="level is-mobile" href="#JDK-6中的substring导致的问题"><span class="level-left"><span class="level-item">2.1.2</span><span class="level-item">JDK 6中的substring导致的问题</span></span></a></li><li><a class="level is-mobile" href="#JDK-7"><span class="level-left"><span class="level-item">2.1.3</span><span class="level-item">JDK 7</span></span></a></li></ul></ul></li><li><a class="level is-mobile" href="#编译器对String字符串拼接的优化"><span class="level-left"><span class="level-item">3</span><span class="level-item">编译器对String字符串拼接的优化</span></span></a></li><li><a class="level is-mobile" href="#字符串拼接的几种方式和区别"><span class="level-left"><span class="level-item">4</span><span class="level-item">字符串拼接的几种方式和区别</span></span></a><ul class="menu-list"><ul class="menu-list"><li><a class="level is-mobile" href="#字符串不变性与字符串拼接"><span class="level-left"><span class="level-item">4.1.1</span><span class="level-item">字符串不变性与字符串拼接</span></span></a></li><li><a class="level is-mobile" href="#1-使用-拼接字符串"><span class="level-left"><span class="level-item">4.1.2</span><span class="level-item">1.使用 + 拼接字符串</span></span></a></li><li><a class="level is-mobile" href="#2-concat"><span class="level-left"><span class="level-item">4.1.3</span><span class="level-item">2.concat</span></span></a></li><li><a class="level is-mobile" href="#3-StringBuffer和StringBuilder"><span class="level-left"><span class="level-item">4.1.4</span><span class="level-item">3.StringBuffer和StringBuilder</span></span></a></li></ul></ul></li><li><a class="level is-mobile" href="#switch对String的支持"><span class="level-left"><span class="level-item">5</span><span class="level-item">switch对String的支持</span></span></a></li><li><a class="level is-mobile" href="#参考资料"><span class="level-left"><span class="level-item">6</span><span class="level-item">参考资料</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-07-06T07:34:00.000Z">2023-07-06</time></p><p class="title"><a href="/2023/07/06/2023-07-06-feign-integrates-ribbon/">feign基于ribbon实现负载均衡</a></p><p class="categories"><a href="/categories/Spring-Cloud/">Spring Cloud</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-05-29T07:34:00.000Z">2023-05-29</time></p><p class="title"><a href="/2023/05/29/2023-05-29-ribbon-components-and-integration-of-gateway/">openFeign整合ribbon实现负载均衡</a></p><p class="categories"><a href="/categories/Spring-Cloud/">Spring Cloud</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-05-29T07:34:00.000Z">2023-05-29</time></p><p class="title"><a href="/2023/05/29/2023-05-29-websocket-clusters/">websocket服务集群搭建与消息收发实现</a></p><p class="categories"><a href="/categories/websocket/">websocket</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-04-13T07:34:00.000Z">2023-04-13</time></p><p class="title"><a href="/2023/04/13/2023-04-13-how-feign-works/">OpenFeign的实现原理</a></p><p class="categories"><a href="/categories/Spring-Cloud/">Spring Cloud</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-04-01T07:34:00.000Z">2023-04-01</time></p><p class="title"><a href="/2023/04/01/2023-04-01-composite-pattern/">设计模式之组合模式</a></p><p class="categories"><a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></p></div></article></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">jiangrz</a><p class="is-size-7"><span>&copy; 2024 jiangrz</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent " target="_blank" rel="noopener" title="备案号：闽ICP备2023008580号-1" href="https://beian.miit.gov.cn">备案号：闽ICP备2023008580号-1</a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>