---
layout: post
title:  "jvm之运行时数据区"
date:   2019-08-19 21:18:50
categories: jvm
tags:  jvm
author: ddmcc
---

* content
{:toc}


 　　Java虚拟机运行Java程序时会将所管理的内存分为不同的数据区域。这些区域的作用以及生命周期都不同。有的随虚拟机进程创建而创建，有的则随线程的启动和结束而建立和销毁。下图是 **JDK1.7**的运行时数据区




## 1.7运行时数据区

![](https://i.loli.net/2019/08/19/zjiESkyLQuWcCHD.png)


如上图所示，可分为线程共享（ **堆**， **方法区**）和线程私有数据区（ **虚拟机栈**， **本地方法栈**， **程序计数器**）。


#### 程序计数器

　　程序计数器是一块较小的空间，可以看成是 **当前线程**所执行字节码的行号指示器。字节码解释器就是通过改变计数器的值来选取下一个指令是什么。Java多线程应用是通过
线程切换竞争CPU时间片实现的。在单核处理器中，同一确定时刻，只会执行一个线程中的指令。所以为了切换后能够恢复到正确的位置，每个线程都需要独自保存程序计数器。
各线程计数器互不影响，独立存储。

如果线程执行的是一个Java方法，那么计数器记录的是字节码指令的地址；如果执行的是native方法，那么计时器为undefined。 **此区域是唯一一块没有规定会发生内存溢出（OutOfMemoryError）的区域**


#### Java虚拟机栈

　　和程序计数器一样Java虚拟机栈也是线程私有的，生命周期和线程相同。虚拟机栈描述的是Java方法的执行的内存模型：每个方法在执行的时候都会创建一个 **栈帧**，用于保存 **局部变量**， **操作数栈**， **动态链接**， **方法出口等**。
每一个方法的执行都对应着一个栈帧在虚拟机栈的的入栈与出栈过程。


我们平常说的`栈内存`就是指的虚拟机栈的`局部变量表`，局部变量表保存着 **8大基本数据类型**和 **对象引用变量（`可能指向堆内存的地址，也可能指向句柄地址`）**以及 **returnAddress（返回类型？）类型** （指向一条字节码指令的地址）。


64长度的long和double会占用两个局部变量空间，其他都只会占用一个。当进入一个方法时，这个方法需要在帧中分配多少的空间是确定的，在方法执行期间不会改变局部变量表大小，即 **栈内存不会动态改变**。


在这区域规定了两种异常：当线程请求的栈深度大于虚拟机的所允许深度，将抛出 **StackOverFlowError**（内存泄露）异常；如果虚拟机可以动态扩展（Java虚拟机栈可以设置长度），如果动态扩展无法申请到足够的长度，那么将抛出
**OutOfMemoryError**（内存溢出）异常。


#### 本地方法栈

　　本地方法栈的作用与Java虚拟机栈类似，它们的区别是虚拟机栈为虚拟机执行Java方法（字节码）服务，而本地方法栈为虚拟机使用Native方法。在Sun HotSpot中（JDK使用的虚拟机），将
Java虚拟机栈和本地方法栈合二为一。在本地方法栈中也会抛出 **StackOverFlowError**（内存泄露）异常和 **OutOfMemoryError**（内存溢出）异常。


#### 堆内存


　　堆内存（Heap Memory）是虚拟机所管理的较大一块内存。也是被所有线程所共享的，在 **虚拟机启动而创建**。此内存区域的作用就是保存对象实例， 几乎所有的对象实例都在这里分配内存， **包括对象和数组**。


Java堆也是垃圾回收器管理的主要区域。从辣鸡回收角度来说，由于基本都采用 **分代收集算法**，所以在Java堆中还可以分为： **新生代和老年代**：再细致一点有`Eden空间`、`From Survivor`、`To Survivor`空间等。
从内存分配角度来看，线程共享的堆内存可能划分出几个线程私有的分配缓存区。但 **其存储的还是对象实例，只不过为了更好的回收内存或更快的分配内存**。


堆内存可以处于在一块地址不连续的内存空间上。其大小可以通过-Xmx和-Xms控制，如果堆中没有内存完成实例分配，并且内存大小不可扩展那么将抛出OutOfMemoryError（内存溢出）异常。


#### 方法区

。。。。。。。。。。。。。