---

layout: post
title:  "mysql索引"
date:   2021-03-31 16:56:23
categories: mysql
tags:  mysql
author: ddmcc
---

* content
{:toc}





## 索引原理

和字典、通讯录原理一样，索引的目的在于提高查询效率，通过不断的缩小数据的查找范围来筛选出最终想要的结果。比如要查找 "张三" 这个人，会先定位在姓 “张” 的人中，然后再从中查找 “三” 这个名。如果没有索引，那么可能需要把整个通讯录都翻一遍才能找到想要的。

在 mysql 中存储引擎用类似的方法使用索引，其先通过值在索引中找到匹配的索引记录，然后根据索引记录来找到对应的数据行。又因为是 `B+` 树索引，按照顺序存储数据，所以可以用来做 `ORDER BY` 和 `GROUP BY` 操作。最后，因为索引存储了实际的列值，所以某些查询只使用索引就能够完成全部查询。据此特性总结索引有以下优点：

- 索引大大减少服务器需要扫描的数据量

- 索引可以帮助服务器避免排序和临时表

- 索引可以将随机IO变为顺序IO

  

> 这边要注意的是B+树索引并不能找到一个给定键值的具体行，能找到的只是被查找数据行所在的页。然后数据库通过把页从磁盘读入到内存，再在内存中进行查找，最后得到要査找的数据。



## 磁盘IO与预读

在介绍索引之前，先了解一下磁盘IO，数据库数据文件是存在磁盘上的，磁盘读取数据靠的是机械运动，每次读取数据花费的时间可以分为寻道时间、旋转延迟、传输时间三个部分。

### **寻道时间**

Tseek是指将读写磁头移动至正确的磁道上所需要的时间。寻道时间越短，I/O操作越快，目前磁盘的平均寻道时间一般在3-15ms，主流磁盘一般在5ms以下

### **旋转延迟**

Trotation是指盘片旋转将请求数据所在的扇区移动到读写磁盘下方所需要的时间。通常用磁盘旋转一周所需时间的1/2表示，比如一个磁盘7200转表示：每分钟能转7200次，也就是说1秒钟能转120次，旋转延迟就是1 / 120 / 2 = 4.17ms

### **传输时间**

指的是从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒，相对于前两个时间可以忽略不计。



那么访问一次磁盘的时间，即一次磁盘IO的时间约等于5+4.17 = 9ms左右。考虑到磁盘IO是非常高昂的操作，计算机操作系统做了一些优化，当一次IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内，因为局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。每一次IO读取的数据我们称之为一页(page)。具体一页有多大数据跟操作系统有关，一般为4k或8k，也就是我们读取一页内的数据时候，实际上才发生了一次IO



## 索引数据结构  [](数据库引擎可用的数据结构比较)

在 mysql 中，索引是 `存储引擎` 层实现的，并没有统一的标准。不同的存储引擎的索引实现并不一样。即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。如：`InnoDB` 中根据主键引用被索引的行，而 `MyISAM` 则通过数据的物理位置引用被索引的行



在 `InnoDB` 中，表中数据都是根据主键顺序存放的，这种存储方式的表叫 **索引组织表**。而 `聚簇索引` 就是按照每张表的主键构造的一棵 `B+` 树，树中同时保存了索引和数据行，数据行被存放在索引的叶子页中。也将 `聚簇索引` 的叶子节点称为 `数据页`。因为无法同时把数据行存放在两个不同的地方，所以一个表只能有一个 `聚簇索引`。如果没有定义主键，`InnoDB` 会选择一个唯一非空索引字段代替，如果没有这样的索引，那么 `InnoDB`会隐式定义一个 `6` 字节的 `rowId` 来作为 `聚簇索引`



> 唯一非空索引：是唯一索引（unique key）并且该字段的值not null



并且 **每一个索引 `InnoDB` 都会为其单独维护一颗 `B+树`**。



假设我们有这么一张表：

```sql
CREATE TABLE `user` (
  `id` bigint(20) NOT NULL,
  `name` varchar(50) DEFAULT NULL,
  `age` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `IDX_AGE` (`age`) USING BTREE
) ENGINE=InnoDB;
```



那么 `InnoDB` 就会为主键 `id` 维护一个 `聚簇索引` ，为索引 `age` 维护一个非主键索引，也叫 `二级索引`。



![markdown](https://ddmcc-1255635056.file.myqcloud.com/8c6a15ad-cbe5-4489-8def-479b9f84416f.png)



![markdown](https://ddmcc-1255635056.file.myqcloud.com/0c60cc55-8414-428b-8325-08f650b8ce83.png)



在上图中可以看出，**二级索引的叶子页存的是主键的值，而聚簇索引叶子页存的是整行数据，聚簇索引的叶子节点也称为数据页**。非叶子节不存储数据行，只存储指向下层叶子的指针和索引键值的虚记录，如19并不真实存在于数据表中



### **一页16kb**

就如上面所说的，磁盘IO是非常高昂的操作。为了减少磁盘IO次数，存储引擎也做了很多的优化。比如会整页读取数据并把一些热数据放在缓冲池中。不同存储引擎缓存单位并不相同，`InnoDB`在默认情况下是 **16kb** ，如果 `InnoDB`做一个单行查找需要读取磁盘，就需要把包含该行的整个页面读入缓冲池进行缓存。假设要随机访问100字节的行， `InnoDB` 将用掉很多缓冲池中额外的内存来缓存这些行，因为每一次都必须读取和缓存一个完整的 `16kb` 页面。而`InnoDB` 索引页大小也是 `16kb` ，意味着访问一个100字节的行可能一共要使用`32kb`的缓存空间（有可能更多，取决于索引树有多深） 



`B+` 索引在数据库中有一个特点是 `高扇出性` ，因此在数据库中，`B+` 树的高度一般都在2 ～ 4层，也就是说查找某一键值的行记录时最多只需要2 ～ 4次IO。前面分析了一次IO大概9ms，意味着查询时间只需0.02 ～ 0.04秒。

> 扇出：是指该模块直接调用的下级模块的个数



假设一个整数字段（bigint）索引为例，字段长度为`8b` ，另外每个索引还跟着 `6b` 指向子树的指针，则每页可以存放索引 16kb * 1024 / 14 = 1170。这棵树高是 4 的时候，就可以存 1170 的 3 次方个值，这已经 16亿了。考虑到树根的数据块总是在内存中的，那么一个 10 亿行的表上一个整数字段的索引，查找一个值最多只需要3 次磁盘IO。这也就是 **索引字段越小越好** 的原因。因为磁盘块的大小也就是一个数据页的大小，是固定的，那么在总数据量固定的情况下，如果数据项占的空间越小，则每页能存的数据项数量越多，那么树的高度越低。这也是为什么 `b+` 树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，每个磁盘块的数据项会大幅度下降，导致树增高



### **索引页、数据页逻辑连续**

每一层的页通过双向链表链接，页按照索引键的顺序排序；另外每个页中的记录也是通过双向链表进行维护的。按照索引键排序的好处就是对于索引键的排序查找和范围查找非常快。如要查找年龄最大的两个人id，由于`b+树`索引是双向链表的，可以快速找到最后一个数据页，并取最后两条数据



```sql
mysql> EXPLAIN SELECT ID FROM user ORDER BY id LIMIT 2;
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | user  | NULL       | index | NULL          | PRIMARY | 8       | NULL |    2 |   100.00 | Using index |
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.01 sec)
```







## 索引查找过程





## 其它索引模型





## 参考

**<<高性能mysql第3版>>**

[MySQL索引原理及慢查询优化](https://tech.meituan.com/2014/06/30/mysql-index.html)

[磁盘I/O那些事](https://tech.meituan.com/2017/05/19/about-desk-io.html)

[MySQL实战45讲](https://time.geekbang.org/column/intro/139)