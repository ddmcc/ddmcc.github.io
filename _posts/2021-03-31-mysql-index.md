---

layout: post
title:  "mysql索引"
date:   2021-03-31 16:56:23
categories: mysql
tags:  mysql
author: ddmcc
---

* content
{:toc}





## 索引原理

和字典、通讯录原理一样，索引的目的在于提高查询效率，通过不断的缩小数据的查找范围来筛选出最终想要的结果。比如要查找 "张三" 这个人，会先定位在姓 “张” 的人中，然后再从中查找 “三” 这个名。如果没有索引，那么可能需要把整个通讯录都翻一遍才能找到想要的。

在 mysql 中存储引擎用类似的方法使用索引，其先通过值在索引中找到匹配的索引记录，然后根据索引记录来找到对应的数据行。又因为是 `B+` 树索引，按照顺序存储数据，所以可以用来做 `ORDER BY` 和 `GROUP BY` 操作。最后，因为索引存储了实际的列值，所以某些查询只使用索引就能够完成全部查询。据此特性总结索引有以下优点：

- 索引大大减少服务器需要扫描的数据量

- 索引可以帮助服务器避免排序和临时表

- 索引可以将随机IO变为顺序IO

  

> 这边要注意的是B+树索引并不能找到一个给定键值的具体行，能找到的只是被查找数据行所在的页。然后数据库通过把页从磁盘读入到内存，再在内存中进行查找，最后得到要査找的数据。



## 磁盘IO与预读

在介绍索引之前，先了解一下磁盘IO，数据库数据文件是存在磁盘上的，磁盘读取数据靠的是机械运动，每次读取数据花费的时间可以分为寻道时间、旋转延迟、传输时间三个部分。

### **寻道时间**

Tseek是指将读写磁头移动至正确的磁道上所需要的时间。寻道时间越短，I/O操作越快，目前磁盘的平均寻道时间一般在3-15ms，主流磁盘一般在5ms以下

### **旋转延迟**

Trotation是指盘片旋转将请求数据所在的扇区移动到读写磁盘下方所需要的时间。通常用磁盘旋转一周所需时间的1/2表示，比如一个磁盘7200转表示：每分钟能转7200次，也就是说1秒钟能转120次，旋转延迟就是1 / 120 / 2 = 4.17ms

### **传输时间**

指的是从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒，相对于前两个时间可以忽略不计。



那么访问一次磁盘的时间，即一次磁盘IO的时间约等于5+4.17 = 9ms左右。考虑到磁盘IO是非常高昂的操作，计算机操作系统做了一些优化，当一次IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内，因为局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。每一次IO读取的数据我们称之为一页(page)。具体一页有多大数据跟操作系统有关，一般为4k或8k，也就是我们读取一页内的数据时候，实际上才发生了一次IO



## 索引数据结构 

在 mysql 中，索引是 `存储引擎` 层实现的，并没有统一的标准。不同的存储引擎的索引实现并不一样。即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。如：`InnoDB` 中根据主键引用被索引的行，而 `MyISAM` 则通过数据的物理位置引用被索引的行



在 `InnoDB` 中，表中数据都是根据主键顺序存放的，这种存储方式的表叫 **索引组织表**。而 `聚簇索引` 就是按照每张表的主键构造的一棵 `B+` 树，树中同时保存了索引和数据行，数据行被存放在索引的叶子页中。也将 `聚簇索引` 的叶子节点称为 `数据页`。因为无法同时把数据行存放在两个不同的地方，所以一个表只能有一个 `聚簇索引`。如果没有定义主键，`InnoDB` 会选择一个唯一非空索引字段代替，如果没有这样的索引，那么 `InnoDB`会隐式定义一个 `6` 字节的 `rowId` 来作为 `聚簇索引`



> 唯一非空索引：是唯一索引（unique key）并且该字段的值not null



并且 **每一个索引 `InnoDB` 都会为其单独维护一颗 `B+树`**。



假设我们有这么一张表：

```sql
CREATE TABLE `user` (
  `id` bigint(20) NOT NULL,
  `name` varchar(50) DEFAULT NULL,
  `age` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `IDX_AGE` (`age`) USING BTREE
) ENGINE=InnoDB;
```



那么 `InnoDB` 就会为主键 `id` 维护一个 `聚簇索引` ，为索引 `age` 维护一个非主键索引，也叫 `二级索引`。



![markdown](https://ddmcc-1255635056.file.myqcloud.com/8c6a15ad-cbe5-4489-8def-479b9f84416f.png)



![markdown](https://ddmcc-1255635056.file.myqcloud.com/0c60cc55-8414-428b-8325-08f650b8ce83.png)



在上图中可以看出，**二级索引的叶子页存的是主键的值，而聚簇索引叶子页存的是整行数据，聚簇索引的叶子节点也称为数据页**。非叶子节不存储数据行，只存储指向下层叶子的指针和索引键值的虚记录，如19并不真实存在于数据表中



### **一页16kb**

就如上面所说的，磁盘IO是非常高昂的操作。为了减少磁盘IO次数，存储引擎也做了很多的优化。比如会整页读取数据并把一些热数据放在缓冲池中。不同存储引擎缓存单位并不相同，`InnoDB`在 **默认情况下是 16kb** ，如果 `InnoDB`做一个单行查找需要读取磁盘，就需要把包含该行的整个页面读入缓冲池进行缓存。假设要随机访问100字节的行， `InnoDB` 将用掉很多缓冲池中额外的内存来缓存这些行，因为每一次都必须读取和缓存一个完整的 `16kb` 页面。而`InnoDB` 索引页大小也是 `16kb` ，意味着访问一个100字节的行可能一共要使用`32kb`的缓存空间（有可能更多，取决于索引树有多深） 



`B+` 索引在数据库中有一个特点是 `高扇出性` ，因此在数据库中，`B+` 树的高度一般都在2 ～ 4层，也就是说查找某一键值的行记录时最多只需要2 ～ 4次IO。前面分析了一次IO大概9ms，意味着查询时间只需0.02 ～ 0.04秒。

> 扇出：是指该模块直接调用的下级模块的个数



以一个整数字段（bigint）索引为例，字段长度为`8b` ，另外每个索引还跟着 `6b` 指向子树的指针，则每页可以存放索引 16kb * 1024 / 14 b = 1170。这棵树高是 4 的时候，就可以存 1170 的 3 次方个值，这已经 16亿了。考虑到树根的数据块总是在内存中的，那么一个 10 亿行的表上一个整数字段的索引，查找一个值最多只需要3 次磁盘IO。这也就是 **索引字段越小越好** 的原因。因为磁盘块的大小也就是一个数据页的大小，是固定的（默认`16k`），那么在总数据量固定的情况下，如果数据项占的空间越小，则每页能存的数据项数量越多，那么树的高度越低。这也是为什么 `b+` 树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，每个磁盘块的数据项会大幅度下降，导致树增高



### **索引页、数据页逻辑连续**

每一层的页通过双向链表链接（Page Header中的PAGE_PREV和PAGE_NEXT记录上、下页的位置），页按照索引键的顺序排序；另外每个页中的记录也是通过单向链表进行维护的（Recorder Header的最后两个字节记录下一行偏移量）。按照索引键排序的好处就是对于索引键的排序查找和范围查找非常快。如要查找年龄最大的两个人id，由于`b+树`索引是双向链表的，可以快速找到最后一个数据页，并取最后两条数据



```sql
mysql> EXPLAIN SELECT id FROM user ORDER BY id LIMIT 2\G
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: user
   partitions: NULL
         type: index
possible_keys: NULL
          key: PRIMARY
      key_len: 8
          ref: NULL
         rows: 2
     filtered: 100.00
        Extra: Using index
1 row in set, 1 warning (0.00 sec)
```



可以看到 Extra 信息中并没有 Using filesort，说明并没有进行额外的排序操作。如果排序字段不是索引字段，那么就会在内存中进行额外的排序操作



未使用索引进行排序：

```sql
mysql> EXPLAIN SELECT ID FROM user ORDER BY name LIMIT 2\G
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: user
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 9
     filtered: 100.00
        Extra: Using filesort
1 row in set, 1 warning (0.00 sec)
```



### **通过二分+遍历查找**

`B+` 树页内索引使用类似 **跳表** 查找。在定位到了页之后，通过页目录（Page Directory）来进行 `二分查找` ，定位到距离数据较近的槽点（Slot）

// todo 描述页内查找过程及图



## 索引的查找



基于聚簇索引和普通二级索引的查询有什么区别呢？



如下面语句，根据 `id` 查找：

```sql
SELECT * FROM user WHERE id = 1;
```



即主键查询的方式，则只需要搜索 **id** 这棵 `B+` 树。在多数情况下，查询优化器倾向于采用聚簇索引，因为聚簇索引索引能够在 `B+` 树索引的叶子节点上直接找到数据。此外，由于定义了数据的逻辑顺序，聚簇索引能够很快地访问针对范围值的查询。查询优化器能够快速发现某一段范围的数据页需要扫描



再如下面语句，根据 `age` 来查找：

```sql
SELECT * FROM user WHERE age = 15;
```



即普通索引查询方式，则需要先搜索 `age`索引树，得到 `id` 的值为 33，再拿着33到 `id` 索引树搜索一次，这个过程称为回表

**也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询**。当然也不是每次用非主键索引查询都会回表，如果要查询的字段都在这棵索引书上，就不需要回表操作



## **索引的维护** 

![markdown](https://ddmcc-1255635056.file.myqcloud.com/b6615bde-2f14-42d4-949d-b5ebec377a15.png)



#### **页分裂**

`B+` 树为了维护索引有序性，在插入新值的时候需要做必要的维护。以上面这个图为例，**第一种情况：** 如果插入点的新值为6，则只需要4后面插入一条新的记录。**第二种情况：** 如果插入新的值为20，这时无法直接在25后面直接插入，需要逻辑上挪动后面的数据，空出位置。更糟的情况是，如果所在的页已经满了，这时就要新建一个新的页，并把部分数据挪过去，这个过程称为页分裂。在这种情况下，不管性能还是空间利用率都会受到影响



**所以通常都会建议使用 `AUTO_INCREMENT` 自增列作为主键** ，这样可以保证数据行是按顺序写入的。最好避免随机的聚簇索引，比如使用 `UUID`作为主键，这样使得聚簇索引的插入变得完全随机。

如果使用自增列作为主键，每次插入都是追加操作，就如上面说的第一种情况。当达到页的最大填充因子时（InnoDB默认最大填充因子是页大小的 15/16，留出部分空间用于后续修改），下一条记录就会写入新的页中。不涉及到挪动其它记录，也不会触发叶子节点的分裂



而有业务逻辑的字段做主键或者使用UUID，则不能保证有序插入，这样写入数据的成本相对较高。总结以下是一些缺点：

- 写入目标页可能已经刷到磁盘上并从缓存中清除，或者是还没有被加载到缓存中，InnoDB在插入之前不得不先找到并从磁盘读取目标页到内存。这将导致大量的随机I/O
- 因为写入是乱序的，InnoDB不得不频繁地做页分裂操作，以便为新的行分配空间，页分裂会导致移动大量的数据，一次插入最少需要修改三个页而不是一个页
- 由于频繁的页分裂，页会变得稀疏并被不规则的填充，最终数据会有碎片



而且通常业务主键都比较大，比如用身份证号做主键，那么每个二级索引的叶子节点都需要存储，这也大大的增加了索引的空间占用。而如果使用整型做主键，则只需4个字节，长整型（bigint）也只需8字节。所以，从性能和存储空间方面考量，自增主键往往是更合理的选择





#### **页合并**

删除记录时，不会实际删除该记录。相反，它将记录标记为已删除，并且它所使用的空间可以被其它记录声明使用



![图5](https://www.percona.com/blog/wp-content/uploads/2017/04/Locality_3.png)

<center style="font-size:14px;color:#ddd;text-decoration:underline">图1</center> 

当页中删除的记录达到`MERGE_THRESHOLD`（默认页体积的50%），InnoDB会开始寻找最靠近的页（前或后）看看是否可以将两个页合并以优化空间使用



![图6](https://www.percona.com/blog/wp-content/uploads/2017/04/Locality_4.png)

<center style="font-size:14px;color:#C0C0C0;text-decoration:underline">图2</center> 



在本例中，页面 `图2` 占用的空间不足一半。`图1` 又有足够的删除数量，现在使用率也不到50%。从InnoDB的角度来看，它们是可合并的



![](https://www.percona.com/blog/wp-content/uploads/2017/04/Locality_5.png)

<center style="font-size:14px;color:#C0C0C0;text-decoration:underline">图3</center> 



合并操作的结果（图3）是图1包含它以前的数据加上图2的数据，图2变成一个空页，可以接纳新数据



![](https://www.percona.com/blog/wp-content/uploads/2017/04/Locality_6.png)

<center style="font-size:14px;color:#C0C0C0;text-decoration:underline">合并后的图2</center> 



当我们进行UPDATE操作，并且使页中记录数量低于阈值时，InnoDB也会进行一样的操作

规则是：页合并发生在删除或更新操作中，关联到当前页的相邻页。如果合并操作成功，在`INFOMATION_SCHEMA.INNODB_METRICS`中的`index_page_merge_successful`将会增加



[了解更多关于页合并与分裂](https://www.percona.com/blog/2017/04/10/innodb-page-merging-and-page-splitting/)



## **建索引的几大原则**

- 最左前缀匹配原则

- 尽量选择区分度高的列作为索引

- 尽量的扩展索引，不要新建索引



## **索引的使用**

#### **单列索引**

 #### **联合索引**

#### **索引覆盖**

#### **索引下推**





## 参考

**<<高性能mysql第3版>>**

[MySQL索引原理及慢查询优化](https://tech.meituan.com/2014/06/30/mysql-index.html)

[磁盘I/O那些事](https://tech.meituan.com/2017/05/19/about-desk-io.html)

[MySQL实战45讲](https://time.geekbang.org/column/intro/139)