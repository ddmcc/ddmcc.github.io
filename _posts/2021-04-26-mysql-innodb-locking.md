---

layout: post
title:  "InnoDB存储引擎中的锁"
date:   2021-04-26 16:56:23
categories: mysql
tags:  mysql
author: ddmcc
---

* content
{:toc}




## InnoDB存储引擎中的锁



我们都知道事务的4个特性，即 **ACID**。mysql 数据库使用加锁的方式来实现其中的 **I** (Isolation隔离性)。对于 InnoDB 存储引擎来说，它 **支持行锁和表锁** ，而且行锁是由存储引擎通过给索引记录加锁来实现的，并且 InnoDB 默认是加行锁。好处就是锁定颗粒度小，发生锁冲突的概率低，并发度高



#### **锁的类型**

InnoDB 实现了两种行级锁：

- 共享锁(**S**) : 允许事务读一行数据
- 排他锁(**X**)：允许事务删除或更新一行数据



**其中，X 锁与任何的锁都不兼容，而 S 锁仅和 S 锁兼容。**即如果一个事务已经获得了行的 **S锁**，那么另外的事务可以立即获得这行的 **S** 锁，因为读取并没有改变行的数据，称这种情况为锁兼容。 但若有其他的事务想获得行的 **X** 锁，则其必须等待事务释放行上的 **S** 锁



![markdown](https://ddmcc-1255635056.file.myqcloud.com/79cd2235-2d37-45cf-8708-72dbc65aee1b.png)



InnoDB 存储引擎除了行锁以外，还有表锁，通常也称为意向锁，其设计目的主要是为了指示事务稍后对表中的行需要哪种类型的锁（共享或独占）。其支持两种意向锁：

- 意向共享锁（IS Lock），事务想要获得一张表中某几行的共享锁
- 意向排他锁（IX Lock），事务想要获得一张表中某几行的排他锁



这样做的目的



## **参考**

[Mysql锁：灵魂七拷问](https://tech.youzan.com/seven-questions-about-the-lock-of-mysql/) 

**《MySQL技术内幕InnoDB存储引擎第2版》**

