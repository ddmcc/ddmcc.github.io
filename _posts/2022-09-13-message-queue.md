---

layout: post
title:  "消息队列基础知识"
date:   2022-09-13 16:56:23
categories: 消息队列
tags:  mq message-queue
author: ddmcc
---

* content
{:toc}



  

## 消息队列应用场景

### 1. **异步处理** 如：秒杀功能

![markdown](https://ddmcc-1255635056.file.myqcloud.com/5fa31af7-7e85-4494-b8ff-4e065f97ea44.png)

通常秒杀功能包括：风险控制、库存锁定、生成订单、短信通知、数据统计等，实际上只要用户请求通过风险控制，并完成库存锁定，就可以返回秒杀结果了，对于后续的生成订单、短信通知等步骤，并不一定要在秒杀请求中完成。可以把请求数据放入请求队列，由队列异步地进行后续的操作


### 2. **流量控制** - 达到雪峰填谷的作用

**如何避免过多的请求压垮我们的系统？** 一个健壮的程序应该可以在海量的请求下，在自身能力范围内尽可能地处理请求，拒绝处理不了的请求，而正常的运行。

**有两种方式：**

1. **使用消息队列隔离网关和后端服务，以达到流量控制和保护后端服务的目的**

   加入消息队列后，整个秒杀流程变为：

   - 网关在收到请求后，将请求放入请求消息队列；

   - 后端服务从请求消息队列中获取 APP 请求，完成后续秒杀处理过程，然后返回结果

![markdown](https://ddmcc-1255635056.file.myqcloud.com/9b11c194-058b-486c-be94-c7ea9627cdf0.png)

当大量请求到达网关时，不会直接冲击后端服务，而先堆积在消息队列中，后端服务根据自己最大处理能力，从队列中进行消费请求。对于超时的请求可以直接丢弃，返回调用者失败即可。运维人员还可以随时增加后端服务的实例数量，进行水平扩容，而不需要对其他服务进行更改。


**优点：** 能根据下游的处理能力自动调节流量，达到“削峰填谷”的作用

**缺点：** 增加了系统调用链环节，导致总体的响应时延变长。上下游系统都要将同步调用改为异步消息，增加了系统的复杂度。


2. **令牌桶的方式**

   **令牌桶的原理是：** 单位时间内只发放固定数量的令牌到令牌桶中，规定服务在处理请求之前必须先从令牌桶中拿出一个令牌，如果令牌桶中没有令牌，则拒绝请求。这样就保证单位时间内，能处理的请求不超过发放令牌的数量，起到了流量控制的作用。

![markdown](https://ddmcc-1255635056.file.myqcloud.com/b044782c-e168-4c8a-b2aa-f3e8e0f84314.png)


令牌桶可以简单地用一个有固定容量的消息队列加一个“令牌发生器”来实现：令牌发生器按照预估的处理能力，匀速生产令牌并放入令牌队列（如果队列满了则丢弃令牌），网关在收到请求时去令牌队列消费一个令牌，获取到令牌则继续调用后端秒杀服务，如果获取不到令牌则直接返回秒杀失败


### 3. 服务解耦

在没有使用消息队列时，上游系统需要应对下游系统化的变化，任何一个下游系统变更都需要尚有系统重新上线一次。所以引入消息队列来解决类似系统耦合过于紧密的问题。引入消息队列后，上游系统在变化时发送一条消息到某主题，所有下游系统都订阅该主题，这样每个下游系统都可以获取一份实时完整的数据。

无论增加、减少或是下游系统需求变化，上游服务都无需做任何更改，实现服务间的解耦



### 消息队列带来的问题和局限性

- 引入消息队列带来延迟问题
- 增加系统的复杂度
- 可能产生数据不一致问题


## 如何选择消息队列

### RabbitMQ

- **优点**
   - 轻量级的消息队列，容易部署和使用
   - 拥有灵活的路由配置，提供 `Exchange` 模块，根据配置的路有规则将生产者消息分发到不同的队列中，支持自己实现路有规则，扩展容易

- **缺点**
   - 对消息堆积支持不好，在它设计里面，消息队列是一个管道，<u>当大量消息积压的时候，会导致 `RabbitMQ` 性能急剧下降</u>
   - **性能相较于其它消息队列是最差的**，大概每秒可以处理几万到十几万消息，如果对性能要求非常高，那就不要选择 `RabbitMQ`
   - `RabbitMQ` 使用 `Erlang` 开发，如果你想基于它做一些扩展和二次开发什么的，建议慎重考虑


### RocketMQ

- **优点**
   - `RocketMQ` 中文社区活跃，大多数问题可以找到中文的答案。另外使用 `Java` 语言开发，贡献者大多都是中文人，源码比较容易读懂，容易对其进行扩展或二次开发
   - <u>对响应做了很多优化</u>，大多数情况下可以做到毫秒级响应
   - 性能要比 `RabbitMQ` 高一个量级，每秒大概能处理几十万条消息
- **缺点**
   - 作为国产消息队列，在国际上还没那么流行，与周边生态系统集成和兼容程度要略逊一筹



### Kafka

- **优点**
   - 与周边生态系统的兼容性是做好的，尤其在大数据和流计算领域，几乎所有相关的开源系统都会优先支持 `Kafka`
   - 设计上大量的使用了批量和异步的思想，使之有着超高的性能。但与 `RocketMQ` 并没有量级上的差异，大约每秒可以处理几十万条消息
- **缺点**
   - 同步收发消息延迟比较高，因为收到一条消息时，`Kafka` 并不会立即发出去，而是要攒一会，一批一起发送。如果每秒消息数量没那么多，延迟反而会比较高



### Pulsar



### 如何选择？

选择中间件的考量维度：`可靠性`，`性能`，`功能`，`可运维性`，`可拓展性`，`是否开源` 及 `社区活跃度`

- 如果说，消息队列并不是你将要构建系统的主角之一，你对消息队列功能和性能都没有很高的要求，只需要一个开箱即用易于维护的产品，建议你使用 `RabbitMQ`。

- 如果你的系统使用消息队列主要场景是处理在线业务，比如在交易系统中用消息队列传递订单，那 `RocketMQ` 的低延迟和金融级的稳定性是你需要的。

- 如果你需要处理海量的消息，像收集日志、监控信息或是前端的埋点这类数据，或是你的应用场景大量使用了大数据、流计算相关的开源产品，那 Kafka 是最适合你的消息队列



