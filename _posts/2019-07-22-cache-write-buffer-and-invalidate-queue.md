---
layout: post
title:  "高速缓存，写缓冲器和无效队列"
date:   2019-07-22 14:13:37
categories: 并发编程
tags: 高速缓存 写缓冲器 无效队列
author: ddmcc
---

* content
{:toc}


## 高速缓存

由于处理器的运行速度远远大于内存的读写速度，为了提高性能，所以硬件设计者引入了高速缓存的概念。

高速缓存是一种速度比内存快，但大小远远比内存小的存储部件。有了它之后，处理器不再与内存发生直接的操作，而是读写高速缓存里的数据，高速缓存在与内存发生读写操作。




### 缓存的结构

缓存的结构类似HashMap，是**链表散列结构**的。有若干个通，每个桶里面都是一个链表。

每个链表节点就是一个缓存条目（Cache Line），缓存条目由三部分组成：**Tag，Data Block，Flag**

- Tag：包含缓存行中数据的位置信息
- Data Block（缓存行）：存储从主内存中读取的数据以及准备写入主内存的数据，一个缓存行可存储多个变量
- Flag：缓存行的状态信息


CPU访问内存时，会通过内存地址解码的三个数据：index（桶编号）、tag（缓存条目的相对编号）、offset（变量在缓存条目中的位置偏移）来获取高速缓存中对应的数据。

### 缓存一致性协议（MESI）

由于每个处理器都有自己的缓存，当多线程并发访问同一共享变量时，就会出现这些线程所在的处理器都会有一份该变量的副本。
当一个线程对副本进行修改后，副本间的数据如何同步呢？这时就要靠**缓存一致性协议**

#### MESI定义

- Modified

该缓存条目的数据是被修改过的，且与主存的数据不一致（还未写回主存）。在任一时刻，多个处理器的高速缓存，相同tag的缓存条目只有一个能处于
该状态。

如果其它处理器要读取同一tag的缓存条目数据之前，要先等数据写回主存。在数据写回主存之后，该缓存条目的状态变为**独享的**。

- Exclusive

已独占的方法保存着副本数据，其它高速缓存的变量副本都是无效的。**该缓存条目的数据与主存数据一致。**

当有其它处理器读取该数据时，该缓存条目的状态变为共享的。如果有处理器修改了该缓存条目的数据，状态则变为修改的。

- Shared

该缓存条目被多个高速缓存同时缓存。且它们的数据都与主存中的一致。

当有缓存对该缓存行的数据进行修改时，改缓存行的状态变为无效的。

- Invalid

该缓存行是无效的，不包含任何内存地址对应的有效副本数据。该状态是缓存条目的初始状态。


#### MESI消息

| 请求消息          | 描述                   | 返回消息  | 描述     |
|------------------|:----------------------:|:--------:|:--------:|
| Read             | 通知其他处理器，主内存正准备读取某个数据。该消息包含待读取数据的内存地址  | Read Response  | 返回请求读取的数据，该消息可能是主内存返回的，也可能是其他高速缓存返回。 |
| Invalidate       | 通知其他处理器将高速缓存中指定内存地址对应的缓存条目状态置为I（无效），即通知这些处理器删除指定内存地址的副本数据  | Invalidate Acknowledge       | 接收Invalidate消息必须回复该消息，表示已经删除其高速缓存上面的数据 |
| Read Invalidate  | 由Read和Invalidate组合而成的复合消息。作用在于通知其他处理器，当前处理器准备更新（Read-Modify-Write）一个数据，请求其他处理器删除自己高速缓存中的副本副本数据。  | Read Response与Invalidate Acknowledge       | 接收到请求的处理器必须返回这两个消息 |
| Writeback        | 该消息包含需要写入主内存的数据及其对应的内存地址  |        |     |


处理器在执行内存读写操作时，在有必要的情况下会往总线发送特定的请求消息，同时每个处理器还会嗅探（也称拦截）总线中由其他处理器发出的请求消息并在一定条件下往总线回复相应的响应消息。
