---
layout: post
title:  "深入理解jvm"
date:   2019-12-30 22:36:00
categories: jvm
tags:  jvm
author: ddmcc
---

* content
{:toc}


上一篇已经介绍了 [jvm运行时数据区](https://ddmcc.space/2019/08/19/understanding-jvm-1/) ，下面将学习垃圾收集器和内存分配与回收策略





#### **为什么要了解gc和内存分配呢？**

- 当需要排查各种内存溢出、内存泄漏问题时
- 当垃圾收集成为系统达到更高并发量的瓶颈时


#### **灵魂拷问**


- 哪些内存需要回收？
- 什么时候回收？
- 怎么回收？


##### **哪些内存需要回收**


 　　在运行区域中，程序计数器，虚拟机栈，本地方法栈三个区域随线程而生，随线程而灭，栈中的栈帧随着方法的进入和退出进行入栈出栈操作，每一个栈帧 **在类结构确定下来就已确定了大小** 因此这几个区域的分配和回收是具有确定性的。不考虑回收的问题


> 一个栈帧就是一个方法，方法内创建的对象只是引用变量在栈中并且大小基本是固定的。当类结构确定时，需要创建多少变量以及方法调用都已经确定了


Java堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间才能知道会创建
哪些对象，这部分内存的分配和回收都是动态的，垃圾回收器所以关注的也是这部分内存。


```java
A a = new A();
B b = new B();
```


- 如有接口A，有两个实现类B和C，B中有变量id，name，C中只有id，那么B，C对象所需的内存是不确定的。b，c在栈变量表大小是固定的，而`new A(),new B()`,引用类型在堆中不固定。
- 单个对象的内存都不固定，更别说方法和方法分支了


##### **什么时候回收**

 　　对象回收肯定是回收“无用”的对象，还需要访问的对象总不能被回收了，那么如何判断一个对象是否无用了呢？
 
 ---
 **引用计数法**
 
  　　很多教科书判断对象是否存活的算法是这样的：给对象添加一个引用计数其器，每当有一个地方引用它，计数器值就加1；当引用失效，计数器值就减1；任何时刻计数器都为0的对象就是不可能再被使用的。
  

**可达性分析（根搜索算法）**

  　　这个算法的基本思路就是通过名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为“**引用链**”，当一个对象到GC Root没有任何
  引用链相连（就是GC Roots到这个对象不可达）时，则这个对象是不可用的。
  
  可作为GC Roots对象包括：
  
- 虚拟机栈中的引用的对象（栈帧中的局部变量表）即**局部变量**
- 方法区中的类静态属性引用的对象即**静态变量**
- 方法区中的常量引用的对象即**常量**
- 本地方法栈中JNI的引用的对象（本地方法中引用对象）


##### **什么是引用？**


---
**强引用**

**软引用**

**弱引用**

**虚引用**

##### **判断对象死亡**


##### **回收的策略与算法**


---
**标记-清除**

**复制算法**

**标记-整理**

**分代收集算法**


##### **垃圾回收器**

