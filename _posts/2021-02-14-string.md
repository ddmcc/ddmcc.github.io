---

layout: post
title:  "String"
date:   2021-02-14 15:18:23
categories: Java基础
tags:  String
author: ddmcc
---

* content
{:toc}


### **String不可变性** 

#### **什么是不可变对象**

       众所周知，`String` 对象是不可变的。那么什么是不可变对象呢？在 [Java教程](https://docs.oracle.com/javase/tutorial/essential/concurrency/immutable.html) 中定义：**如果一个对象在构造后状态无法改变，则该对象被视为不可变。**

>不能改变状态的意思是，不能改变对象内的成员变量，包括基本数据类型的值不能改变，引用类型的变量不能指向其他的对象，引用类型指向的对象的状态也不能改变。




#### **不可变对象的遵守策略（规则）**

- 类中所有字段都被 `final` 修饰，并且是私有的，也就是被 `private` 修饰。
- 不能提供修改字段或字段引用对象的 `setter` 方法。
- 不允许子类重写方法
- 如果实例字段包含对可变对象的引用，则不允许更改这些对象：
  - 不要提供修改可变对象的方法。
  - 不要直接返回可变对象的引用。如有必要，可创建内部可变对象的副本，并返回可变对象的副本。
  

#### **String的不可变性**

定义一个字符串 `s`：

```java
    public static void main(String[] args) {
        String s = "abcd";
        System.out.println(s);

        s = "abcdef";
        System.out.println(s);
    }
```

输出结果为：

```java
abcd
abcdef
```

首先创建一个对象 `s` ，并赋值为abcd，然后再赋值为abcdef。从输出结果可以看出s的值确实改变了，那么为什么还说String对象是不可变的呢？

其实 `s` 变量只是保存了对象的引用，该引用指向了堆中具体的对象。如下图：

![](https://ddmcc-1255635056.file.myqcloud.com/8d3094e8-4633-4c51-910d-e6583eaf13b0.png)


然后又创建了一个新的对象abcdef， 而引用s重新指向了这个新的对象，原来的对象abcd还在内存中存在，并没有改变。如下图：

![](https://ddmcc-1255635056.file.myqcloud.com/28a6c330-391f-4512-8732-ad9d6b60d7d9.png)


所以上面的代码仅仅改变了s的引用地址


##### **为什么String对象是不可变的？**

要理解String的不可变性，先看String类的源码：

```java
public final class String
    implements java.io.Serializable, Comparable<String>, CharSequence {
    /** The value is used for character storage. */
    private final char value[];

    /** Cache the hash code for the string */
    private int hash; // Default to 0
```

通过源码可以发现：String类内部是用一个字符数组来维护值的，并且被申明为 `private final` ，也就是value字符数组在对象被构造后就不允许重新赋值了。并且类内部也没有提供可以修改value数组值的setter方法，
所以可以认为String对象是不可变的。

可能会发现String类还提供了很多方法可以修改字符串值的方法：**substring** , **concat** , **replace** , **replaceAll** 等等。

比如 `substring` 方法：

```java
    public static void main(String[] args) {
        String s = "abcd";
        System.out.println(s);
        System.out.println(s.substring(1));
    }
```

执行后输出结果：

```java
abcd
bcd
```

可以看到s的值确实是变了。这解释起来也很容易，看 `substring` 方法实现就明白了：


```java
    public String substring(int beginIndex) {
        if (beginIndex < 0) {
            throw new StringIndexOutOfBoundsException(beginIndex);
        }
        int subLen = value.length - beginIndex;
        if (subLen < 0) {
            throw new StringIndexOutOfBoundsException(subLen);
        }
        return (beginIndex == 0) ? this : new String(value, beginIndex, subLen);
    }
```

源码并不是去修改的 value 数组里的值，而是重新创建一个新的对象，并把新的对象引用赋值给s。其它修改字符串值的方法也都一样，都是创建新的对象返回。


##### **String的值真的不可变吗？**

value变量是 `private final` 的，也就是初始化后不可修改。它是引用变量，虽然不能重新指向其它堆内存地址，但可以通过反射去修改堆里的值。

```java
    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException {
        String s = "abcd";
        Field field = String.class.getDeclaredField("value");
        field.setAccessible(true);
        char[] chars = (char[]) field.get(s);
        chars[1] = '%';
        System.out.println(s);
    }
```


输出结果为：

```java
a%cd
```

这个反射的实例还可以说明一个问题：如果一个对象，他组合的其他对象的状态是可以改变的，那么这个对象很可能不是不可变对象。例如一个Car对象，它组合了一个Wheel对象，虽然这个Wheel对象声明成了private final 的，但是这个Wheel对象内部的状态可以改变， 那么就不能很好的保证Car对象不可变。


### **JDK6与JDK7中String类实现的区别**

##### **JDK 6**

>String是通过字符数组实现的。在jdk 6 中，String类包含三个成员变量：char value[]， int offset，int count。他们分别用来存储真正的字符数组，数组的第一个位置索引以及字符串中包含的字符个数。


下面是jdk1.6中的源码:

```java
public final class String
    implements java.io.Serializable, Comparable<String>, CharSequence
{
    /** The value is used for character storage. */
    private final char value[];

    /** The offset is the first index of the storage that is used. */
    private final int offset;

    /** The count is the number of characters in the String. */
    private final int count;

    /** Cache the hash code for the string */
    private int hash; // Default to 0


    // JDK 6
    // Package private constructor which shares value array for speed.
    String(int offset, int count, char value[]) {
        this.value = value;
        this.offset = offset;
        this.count = count;
    }
    
    // substring
    public String substring(int beginIndex, int endIndex) {
        //check boundary
        return  new String(offset + beginIndex, endIndex - beginIndex, value);
    }
    
    // concat
    public String concat(String str) {
        return new String(0, count + otherLen, buf);
    }    

    // 其它修改字符串的方法
}
```


当调用substring,concat等方法的时候，会创建一个新的string对象，但是这个string的值仍然指向堆中的同一个字符数组。这两个对象中只有count和offset 的值是不同的


![](https://ddmcc-1255635056.file.myqcloud.com/45b726c9-42c8-44dd-a8ae-2c81b3f8337d.png)

##### **JDK 6中的substring导致的问题**

如果你有一个很长很长的字符串，但是当你使用substring进行切割的时候你只需要很短的一段。这可能导致性能问题，因为你需要的只是一小段字符序列，但是你却引用了整个字符串（因为这个非常长的字符数组一直在被引用，所以无法被回收，就可能导致内存泄露）。在JDK 6中，一般用以下方式来解决该问题，原理其实就是生成一个新的字符串并引用他。

```java
x = x.substring(x, y) + ""
```

>内存泄露：在计算机科学中，内存泄漏指由于疏忽或错误造成程序未能释放已经不再使用的内存。 内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费。


concat也同样有该问题，如果对象a只需要很小一段字符序列，对象b去拼接了很长的字符串，这就导致如果a对象没被回收，这个很长很长的字符数组就一直不会被释放。


##### **JDK 7**

上面提到的问题，在jdk 7中得到解决。在jdk 7 中，substring，concat等方法会在堆内存中创建一个新的数组。


![](https://ddmcc-1255635056.file.myqcloud.com/202bf514-acd6-4e8d-b6d0-b86ea7abbec3.png)



### **参考资料**

[定义不可变对象的策略](https://docs.oracle.com/javase/tutorial/essential/concurrency/imstrat.html)

[为什么String在java中是不可变的？](https://www.zhihu.com/question/336799824/answer/763164656)