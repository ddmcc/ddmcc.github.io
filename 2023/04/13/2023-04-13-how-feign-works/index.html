<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>OpenFeign的实现原理 - ddmcc</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="ddmcc"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="ddmcc"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="前言在过去使用feign时，会将feign接口单独放在一个包，并在接口类上声明 @FeignClient(name &amp;#x3D; 服务名)， 在接口方法上声明 @xxxMapping(接口路径) ，实现者和使用者都会去引入这个包。对于 使用者 来说只需要注入接口类，然后调用对应的方法就能调用到在另一个服务的实现者实现的逻辑"><meta property="og:type" content="article"><meta property="og:title" content="OpenFeign的实现原理"><meta property="og:url" content="http://example.com/2023/04/13/2023-04-13-how-feign-works/"><meta property="og:site_name" content="ddmcc"><meta property="og:description" content="前言在过去使用feign时，会将feign接口单独放在一个包，并在接口类上声明 @FeignClient(name &amp;#x3D; 服务名)， 在接口方法上声明 @xxxMapping(接口路径) ，实现者和使用者都会去引入这个包。对于 使用者 来说只需要注入接口类，然后调用对应的方法就能调用到在另一个服务的实现者实现的逻辑"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://ddmcc-1255635056.file.myqcloud.com/060a59aa-6a36-480b-a856-d979f9bd8364.png"><meta property="article:published_time" content="2023-04-13T07:34:00.000Z"><meta property="article:modified_time" content="2023-05-04T10:52:02.539Z"><meta property="article:author" content="jiangrz"><meta property="article:tag" content="OpenFeign"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://ddmcc-1255635056.file.myqcloud.com/060a59aa-6a36-480b-a856-d979f9bd8364.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2023/04/13/2023-04-13-how-feign-works/"},"headline":"OpenFeign的实现原理","image":["https://ddmcc-1255635056.file.myqcloud.com/060a59aa-6a36-480b-a856-d979f9bd8364.png"],"datePublished":"2023-04-13T07:34:00.000Z","dateModified":"2023-05-04T10:52:02.539Z","author":{"@type":"Person","name":"jiangrz"},"publisher":{"@type":"Organization","name":"ddmcc","logo":{"@type":"ImageObject","url":{"text":"jiangrz"}}},"description":"前言在过去使用feign时，会将feign接口单独放在一个包，并在接口类上声明 @FeignClient(name &#x3D; 服务名)， 在接口方法上声明 @xxxMapping(接口路径) ，实现者和使用者都会去引入这个包。对于 使用者 来说只需要注入接口类，然后调用对应的方法就能调用到在另一个服务的实现者实现的逻辑"}</script><link rel="canonical" href="http://example.com/2023/04/13/2023-04-13-how-feign-works/"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.1.1"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">jiangrz</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="GitHub" href="https://github.com/ddmcc/ddmcc.github.io">GitHub</a><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ddmcc/ddmcc.github.io"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-04-13T07:34:00.000Z" title="2023/4/13 15:34:00">2023-04-13</time>发表</span><span class="level-item"><time dateTime="2023-05-04T10:52:02.539Z" title="2023/5/4 18:52:02">2023-05-04</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Spring-Cloud/">Spring Cloud</a></span></div></div><h1 class="title is-3 is-size-4-mobile">OpenFeign的实现原理</h1><div class="content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在过去使用feign时，会将feign接口单独放在一个包，并在接口类上声明 <code>@FeignClient(name = 服务名)</code>， 在接口方法上声明 <code>@xxxMapping(接口路径)</code> ，实现者和使用者都会去引入这个包。对于 <strong>使用者</strong> 来说只需要注入接口类，然后调用对应的方法就能调用到在另一个服务的实现者实现的逻辑</p>
<span id="more"></span>


<p>根据过去的经验我猜测，在调用侧上的原理和mybatis相似，扫描所有被 <code>@FeignClient</code> 注解声明的类，然后为其生成代理对象，当执行某个方法时，会被拦截转而请求方法上的链接，不同的是mybatis是找到这个方法对应的MappedStatement对象，然后执行sql。实现侧的话则和普通controller类似，将这些方法封装成一个个handle并注册到handleMapping中，等待被DispatcherServlet调用</p>
<h2 id="调用侧"><a href="#调用侧" class="headerlink" title="调用侧"></a>调用侧</h2><h4 id="扫描-FeignClient注解类"><a href="#扫描-FeignClient注解类" class="headerlink" title="扫描@FeignClient注解类"></a>扫描@FeignClient注解类</h4><p>为了验证上面的猜想，我们从 <code>@EnableFeignClients</code> 入手，看看启动时都做了什么</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(FeignClientsRegistrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableFeignClients &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到注解 <code>EnableFeignClients</code> 通过 <code>@Import</code> 注解导入一个配置类 <code>FeignClientsRegistrar</code>，它实现了 <code>ImportBeanDefinitionRegistrar</code> 接口，这么说在启动的时候，<code>FeignClientsRegistrar</code> 类中的 <code>registerBeanDefinitions</code> 方法会被调用，来往Spring容器中注册 <code>BeanDefinition</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">    <span class="comment">// 解析 @EnableFeignClients 注解中的配置，并注册到容器</span></span><br><span class="line">    registerDefaultConfiguration(metadata, registry);</span><br><span class="line">    <span class="comment">// 扫描被 @FeignClient 注解声明的接口，并注册到容器</span></span><br><span class="line">    registerFeignClients(metadata, registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>registerFeignClients</code> 方法是重点，这里扫描到所有 <code>@FeignClient</code> 注解声明的接口后，并做了一系列的处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerFeignClients</span><span class="params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">    LinkedHashSet&lt;BeanDefinition&gt; candidateComponents = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 获取EnableFeignClients注解配置属性</span></span><br><span class="line">    Map&lt;String, Object&gt; attrs = metadata.getAnnotationAttributes(EnableFeignClients.class.getName());</span><br><span class="line">    <span class="comment">// 获取配置的clients，如果有配置，则不再进行类路径扫描</span></span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt;[] clients = attrs == <span class="literal">null</span> ? <span class="literal">null</span> : (Class&lt;?&gt;[]) attrs.get(<span class="string">&quot;clients&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (clients == <span class="literal">null</span> || clients.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">ClassPathScanningCandidateComponentProvider</span> <span class="variable">scanner</span> <span class="operator">=</span> getScanner();</span><br><span class="line">        scanner.setResourceLoader(<span class="built_in">this</span>.resourceLoader);</span><br><span class="line">        <span class="comment">// 指定要扫描的注解</span></span><br><span class="line">        scanner.addIncludeFilter(<span class="keyword">new</span> <span class="title class_">AnnotationTypeFilter</span>(FeignClient.class));</span><br><span class="line">        <span class="comment">// 获取EnableFeignClients中配置的包路径，如果没有就默认为注解所在类的包路径</span></span><br><span class="line">        Set&lt;String&gt; basePackages = getBasePackages(metadata);</span><br><span class="line">        <span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">            <span class="comment">// 扫描并构建ScannedGenericBeanDefinition</span></span><br><span class="line">            candidateComponents.addAll(scanner.findCandidateComponents(basePackage));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; clazz : clients) &#123;</span><br><span class="line">            candidateComponents.add(<span class="keyword">new</span> <span class="title class_">AnnotatedGenericBeanDefinition</span>(clazz));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (BeanDefinition candidateComponent : candidateComponents) &#123;</span><br><span class="line">        <span class="keyword">if</span> (candidateComponent <span class="keyword">instanceof</span> AnnotatedBeanDefinition beanDefinition) &#123;</span><br><span class="line">            <span class="comment">// verify annotated class is an interface</span></span><br><span class="line">            <span class="type">AnnotationMetadata</span> <span class="variable">annotationMetadata</span> <span class="operator">=</span> beanDefinition.getMetadata();</span><br><span class="line">            Assert.isTrue(annotationMetadata.isInterface(), <span class="string">&quot;@FeignClient can only be specified on an interface&quot;</span>);</span><br><span class="line"></span><br><span class="line">            Map&lt;String, Object&gt; attributes = annotationMetadata</span><br><span class="line">                    .getAnnotationAttributes(FeignClient.class.getCanonicalName());</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> getClientName(attributes);</span><br><span class="line">            <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> annotationMetadata.getClassName();</span><br><span class="line">            <span class="comment">// 注册client的配置到容器  -&gt; FeignClientSpecification</span></span><br><span class="line">            registerClientConfiguration(registry, name, className, attributes.get(<span class="string">&quot;configuration&quot;</span>));</span><br><span class="line">            <span class="comment">// 创建client的BeanDefinition，注册到容器</span></span><br><span class="line">            registerFeignClient(registry, annotationMetadata, attributes);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先获取 <code>@EnableFeignClients</code> 的配置，看是否有配置指定的client，有的话就只生成配置的BeanDefinition，没有的话再用ClassPathScanningCandidateComponentProvider来扫描被 <code>@FeignClient</code> 注解标记的类，扫描的路径的话看有没有配置，如果没有配置则默认为 <code>@EnableFeignClients</code> 注解所在类的所在包开始向下扫描。扫描到的类都会生成一个BeanDefinition，可以把BeanDefinition看成对每个标有 <code>@FeignClient</code> 注解的类信息的封装。拿到所有BeanDefinition之后，遍历调用 <code>registerClientConfiguration</code> 和 <code>registerFeignClient</code> </p>
<p><strong>registerClientConfiguration</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">registerClientConfiguration</span><span class="params">(BeanDefinitionRegistry registry, </span></span><br><span class="line"><span class="params">                                        Object name, </span></span><br><span class="line"><span class="params">                                        Object className, </span></span><br><span class="line"><span class="params">                                        Object configuration)</span> &#123;</span><br><span class="line">    <span class="type">BeanDefinitionBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> BeanDefinitionBuilder.genericBeanDefinition(FeignClientSpecification.class);</span><br><span class="line">    builder.addConstructorArgValue(name);</span><br><span class="line">    builder.addConstructorArgValue(className);</span><br><span class="line">    builder.addConstructorArgValue(configuration);</span><br><span class="line">    registry.registerBeanDefinition(name + <span class="string">&quot;.&quot;</span> + FeignClientSpecification.class.getSimpleName(), builder.getBeanDefinition());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的意思就是拿出再 <code>@FeignClient</code> 指定的配置类，也就是 <code>configuration</code> 属性，然后构建一个bean class为FeignClientSpecification。这个类的最主要作用就是将每个client的配置类（<code>configuration</code> 属性）封装成一个 <code>FeignClientSpecification</code> 的 <code>BeanDefinition</code>，注册到spring容器中</p>
<p><strong>registerFeignClient</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">registerFeignClient</span><span class="params">(BeanDefinitionRegistry registry, </span></span><br><span class="line"><span class="params">                                AnnotationMetadata annotationMetadata,</span></span><br><span class="line"><span class="params">                                Map&lt;String, Object&gt; attributes)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> annotationMetadata.getClassName();</span><br><span class="line">    <span class="keyword">if</span> (String.valueOf(<span class="literal">false</span>).equals(</span><br><span class="line">            environment.getProperty(<span class="string">&quot;spring.cloud.openfeign.lazy-attributes-resolution&quot;</span>, String.valueOf(<span class="literal">false</span>)))) &#123;</span><br><span class="line">        eagerlyRegisterFeignClientBeanDefinition(className, attributes, registry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        lazilyRegisterFeignClientBeanDefinition(className, attributes, registry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">eagerlyRegisterFeignClientBeanDefinition</span><span class="params">(String className, Map&lt;String, Object&gt; attributes,</span></span><br><span class="line"><span class="params">        BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">    validate(attributes);</span><br><span class="line">    <span class="comment">// 构建class为FeignClientFactoryBean的BeanDefinition</span></span><br><span class="line">    <span class="type">BeanDefinitionBuilder</span> <span class="variable">definition</span> <span class="operator">=</span> BeanDefinitionBuilder.genericBeanDefinition(FeignClientFactoryBean.class);</span><br><span class="line">    definition.addPropertyValue(<span class="string">&quot;url&quot;</span>, getUrl(<span class="literal">null</span>, attributes));</span><br><span class="line">    definition.addPropertyValue(<span class="string">&quot;path&quot;</span>, getPath(<span class="literal">null</span>, attributes));</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> getName(attributes);</span><br><span class="line">    definition.addPropertyValue(<span class="string">&quot;name&quot;</span>, name);</span><br><span class="line">    <span class="type">String</span> <span class="variable">contextId</span> <span class="operator">=</span> getContextId(<span class="literal">null</span>, attributes);</span><br><span class="line">    definition.addPropertyValue(<span class="string">&quot;contextId&quot;</span>, contextId);</span><br><span class="line">    definition.addPropertyValue(<span class="string">&quot;type&quot;</span>, className);</span><br><span class="line">    definition.addPropertyValue(<span class="string">&quot;dismiss404&quot;</span>, Boolean.parseBoolean(String.valueOf(attributes.get(<span class="string">&quot;dismiss404&quot;</span>))));</span><br><span class="line">    <span class="type">Object</span> <span class="variable">fallback</span> <span class="operator">=</span> attributes.get(<span class="string">&quot;fallback&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fallback != <span class="literal">null</span>) &#123;</span><br><span class="line">        definition.addPropertyValue(<span class="string">&quot;fallback&quot;</span>,</span><br><span class="line">                (fallback <span class="keyword">instanceof</span> Class ? fallback : ClassUtils.resolveClassName(fallback.toString(), <span class="literal">null</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">fallbackFactory</span> <span class="operator">=</span> attributes.get(<span class="string">&quot;fallbackFactory&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fallbackFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">        definition.addPropertyValue(<span class="string">&quot;fallbackFactory&quot;</span>, fallbackFactory <span class="keyword">instanceof</span> Class ? fallbackFactory</span><br><span class="line">                : ClassUtils.resolveClassName(fallbackFactory.toString(), <span class="literal">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    definition.addPropertyValue(<span class="string">&quot;fallbackFactory&quot;</span>, attributes.get(<span class="string">&quot;fallbackFactory&quot;</span>));</span><br><span class="line">    definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);</span><br><span class="line">    definition.addPropertyValue(<span class="string">&quot;refreshableClient&quot;</span>, isClientRefreshEnabled());</span><br><span class="line">    String[] qualifiers = getQualifiers(attributes);</span><br><span class="line">    <span class="keyword">if</span> (ObjectUtils.isEmpty(qualifiers)) &#123;</span><br><span class="line">        qualifiers = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; contextId + <span class="string">&quot;FeignClient&quot;</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// This is done so that there&#x27;s a way to retrieve qualifiers while generating AOT</span></span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">    definition.addPropertyValue(<span class="string">&quot;qualifiers&quot;</span>, qualifiers);</span><br><span class="line">    <span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> definition.getBeanDefinition();</span><br><span class="line">    beanDefinition.setAttribute(FactoryBean.OBJECT_TYPE_ATTRIBUTE, className);</span><br><span class="line">    <span class="comment">// has a default, won&#x27;t be null</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">primary</span> <span class="operator">=</span> (Boolean) attributes.get(<span class="string">&quot;primary&quot;</span>);</span><br><span class="line">    beanDefinition.setPrimary(primary);</span><br><span class="line">    <span class="type">BeanDefinitionHolder</span> <span class="variable">holder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(beanDefinition, className, qualifiers);</span><br><span class="line">    BeanDefinitionReaderUtils.registerBeanDefinition(holder, registry);</span><br><span class="line">    registerRefreshableBeanDefinition(registry, contextId, Request.Options.class, OptionsFactoryBean.class);</span><br><span class="line">    registerRefreshableBeanDefinition(registry, contextId, RefreshableUrl.class, RefreshableUrlFactoryBean.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下会调用 <code>eagerlyRegisterFeignClientBeanDefinition</code> ，所以我们来看这个方法做了哪些事。先构建了一个class为 <code>FeignClientFactoryBean</code> 的BeanDefinition，这个class实现了FactoryBean接口，spring在生成bean的时候判断BeanDefinition中bean的class如果是FactoryBean的实现的话，会调用这个实现类的getObject来获取对象。</p>
<p>到这里生成动态代理对象的准备工作就基本做完了，再来总结一下前面做了哪些：根据  <code>@EnableFeignClients</code> 注解的配置扫描指定（不指定就默认路径下的）包下所有加了 <code>@FeignClient</code> 注解的类，然后每个类都会生成一个BeanDefinition，随后 <strong>遍历每个BeanDefinition</strong> ，然后取出每个 <code>@FeignClient</code> 注解的属性，构造class为 <code>FeignClientFactoryBean</code> 的新的BeanDefinition，随后注册到spring容器中，同时有配置类（注解上configuration属性）的也会将配置类构件出一个class为 <code>FeignClientSpecification</code> 的BeanDefinition注册到spring容器中</p>
<h4 id="生成动态代理对象"><a href="#生成动态代理对象" class="headerlink" title="生成动态代理对象"></a>生成动态代理对象</h4><p>上面每个 <code>@FeignClient</code> 都生成了一个 class为 <code>FeignClientFactoryBean</code> 的BeanDefinition，后面就会根据这个BeanDefinition来生成动态代理对象。因为FeignClientFactoryBean实现了FactoryBean接口，所以会调用 <code>getObject()</code> 来获取对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getTarget();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;T&gt; T <span class="title function_">getTarget</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// FeignClientFactory 里面保存了每个client的配置，也就是FeignClientSpecification（具体可以看FeignAutoConfiguration）</span></span><br><span class="line">    <span class="type">FeignClientFactory</span> <span class="variable">feignClientFactory</span> <span class="operator">=</span> beanFactory != <span class="literal">null</span> ? beanFactory.getBean(FeignClientFactory.class)</span><br><span class="line">            : applicationContext.getBean(FeignClientFactory.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取builder，Feign.Builder对象在FeignClientsConfiguration中配置</span></span><br><span class="line">    Feign.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> feign(feignClientFactory);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断是否配置了url属性，url链接直连访问</span></span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasText(url) &amp;&amp; !isUrlAvailableInConfig(contextId)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (LOG.isInfoEnabled()) &#123;</span><br><span class="line">            LOG.info(<span class="string">&quot;For &#x27;&quot;</span> + name + <span class="string">&quot;&#x27; URL not provided. Will try picking an instance via load-balancing.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!name.startsWith(<span class="string">&quot;http&quot;</span>)) &#123;</span><br><span class="line">            url = <span class="string">&quot;http://&quot;</span> + name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            url = name;</span><br><span class="line">        &#125;</span><br><span class="line">        url += cleanPath();</span><br><span class="line">        <span class="comment">// 负载均衡访问</span></span><br><span class="line">        <span class="keyword">return</span> (T) loadBalance(builder, feignClientFactory, <span class="keyword">new</span> <span class="title class_">HardCodedTarget</span>&lt;&gt;(type, name, url));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(url) &amp;&amp; !url.startsWith(<span class="string">&quot;http&quot;</span>)) &#123;</span><br><span class="line">        url = <span class="string">&quot;http://&quot;</span> + url;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="built_in">this</span>.url + cleanPath();</span><br><span class="line">    <span class="type">Client</span> <span class="variable">client</span> <span class="operator">=</span> getOptional(feignClientFactory, Client.class);</span><br><span class="line">    <span class="keyword">if</span> (client != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (client <span class="keyword">instanceof</span> FeignBlockingLoadBalancerClient) &#123;</span><br><span class="line">            <span class="comment">// not load balancing because we have a url,</span></span><br><span class="line">            <span class="comment">// but Spring Cloud LoadBalancer is on the classpath, so unwrap</span></span><br><span class="line">            client = ((FeignBlockingLoadBalancerClient) client).getDelegate();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (client <span class="keyword">instanceof</span> RetryableFeignBlockingLoadBalancerClient) &#123;</span><br><span class="line">            <span class="comment">// not load balancing because we have a url,</span></span><br><span class="line">            <span class="comment">// but Spring Cloud LoadBalancer is on the classpath, so unwrap</span></span><br><span class="line">            client = ((RetryableFeignBlockingLoadBalancerClient) client).getDelegate();</span><br><span class="line">        &#125;</span><br><span class="line">        builder.client(client);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    applyBuildCustomizers(feignClientFactory, builder);</span><br><span class="line"></span><br><span class="line">    <span class="type">Targeter</span> <span class="variable">targeter</span> <span class="operator">=</span> get(feignClientFactory, Targeter.class);</span><br><span class="line">    <span class="keyword">return</span> targeter.target(<span class="built_in">this</span>, builder, feignClientFactory, resolveTarget(feignClientFactory, contextId, url));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先获取FeignClientFactory，这里保存了每个client的配置，然后获取到一个Feign.Builder，然后调用feign方法。feign方法主要事设置一些默认的组件，如果需要更改上面的这些组件，可以通过 <code>@FeignClient</code> 的 <code>configuration</code> 属性配置配置类，在配置类里面替换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Feign.Builder <span class="title function_">feign</span><span class="params">(FeignClientFactory context)</span> &#123;</span><br><span class="line">    <span class="type">FeignLoggerFactory</span> <span class="variable">loggerFactory</span> <span class="operator">=</span> get(context, FeignLoggerFactory.class);</span><br><span class="line">    <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> loggerFactory.create(type);</span><br><span class="line"></span><br><span class="line">    Feign.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> get(context, Feign.Builder.class)</span><br><span class="line">            <span class="comment">// required values</span></span><br><span class="line">            .logger(logger)</span><br><span class="line">            .encoder(get(context, Encoder.class))</span><br><span class="line">            .decoder(get(context, Decoder.class))</span><br><span class="line">            .contract(get(context, Contract.class));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从配置文件中读取feign的配置</span></span><br><span class="line">    configureFeign(context, builder);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> builder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面就是这段逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!StringUtils.hasText(url) &amp;&amp; !isUrlAvailableInConfig(contextId)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (LOG.isInfoEnabled()) &#123;</span><br><span class="line">        LOG.info(<span class="string">&quot;For &#x27;&quot;</span> + name + <span class="string">&quot;&#x27; URL not provided. Will try picking an instance via load-balancing.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!name.startsWith(<span class="string">&quot;http&quot;</span>)) &#123;</span><br><span class="line">        url = <span class="string">&quot;http://&quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        url = name;</span><br><span class="line">    &#125;</span><br><span class="line">    url += cleanPath();</span><br><span class="line">    <span class="comment">// 负载均衡访问</span></span><br><span class="line">    <span class="keyword">return</span> (T) loadBalance(builder, feignClientFactory, <span class="keyword">new</span> <span class="title class_">HardCodedTarget</span>&lt;&gt;(type, name, url));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先判断有没有指定url，也就是在 <code>@FeignClient</code> 注解中指定的url属性，如果配置了这个属性，就不通过注册中心，直接访问链接，<code>isUrlAvailableInConfig()</code> 也是判断在配置文件中是否配置了url属性 。一般情况下这个是不配置的，因为得从注册中心获取服务的ip和端口列表，然后进行负载均衡访问。所以从这也也可以看出，没有注册中心，feign也是能够跑的，只要配置url属性就行</p>
<p>下面就是拼接url，name就是我们在 <code>@FeignClient</code> 配置的value，一般是服务名，这段代码拼出来的结果就类似 <code>http://ServiceA</code>，之后就会走loadBalance方法，传入一个HardCodedTarget参数，封装了feign客户端接口的类型、服务的名称、还有刚构建的url</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; T <span class="title function_">loadBalance</span><span class="params">(Feign.Builder builder, FeignClientFactory context, HardCodedTarget&lt;T&gt; target)</span> &#123;</span><br><span class="line">    <span class="type">Client</span> <span class="variable">client</span> <span class="operator">=</span> getOptional(context, Client.class);</span><br><span class="line">    <span class="keyword">if</span> (client != <span class="literal">null</span>) &#123;</span><br><span class="line">        builder.client(client);</span><br><span class="line">        applyBuildCustomizers(context, builder);</span><br><span class="line">        <span class="type">Targeter</span> <span class="variable">targeter</span> <span class="operator">=</span> get(context, Targeter.class);</span><br><span class="line">        <span class="keyword">return</span> targeter.target(<span class="built_in">this</span>, builder, context, target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">            <span class="string">&quot;No Feign Client for loadBalancing defined. Did you forget to include spring-cloud-starter-loadbalancer?&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先从feign客户端对应的ioc容器中获取一个Client，这个client对象由配置类注册，默认情况下由 <code>DefaultFeignLoadBalancerConfiguration</code> 提供，使用了 <code>spring-cloud-starter-loadbalancer</code> 组件，可能就由 <code>FeignRibbonClientAutoConfiguration</code> 去提供。在旧版本openfeign下使用了开启了ribbon(<code>spring.cloud.loadbalancer.ribbon.enabled</code>)的话由 <code>FeignRibbonClientAutoConfiguration</code> 提供</p>
<p>获取到Client后，接下来获取到Targeter，Targeter是通过 <code>FeignAutoConfiguration</code> 来配置的，默认是DefaultTargeter，如果整合hystrix或sentinel就是FeignCircuitBreakerTargeter（看有没有CircuitBreakerFactory）。然后调用DefaultTargeter的target方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">target</span><span class="params">(FeignClientFactoryBean factory, Feign.Builder feign, FeignClientFactory context,</span></span><br><span class="line"><span class="params">        Target.HardCodedTarget&lt;T&gt; target)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> feign.target(target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后调用Feign.Builder的tartget方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">target</span><span class="params">(Target&lt;T&gt; target)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> build().newInstance(target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Feign <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">super</span>.enrich();</span><br><span class="line"></span><br><span class="line">  MethodHandler.Factory&lt;Object&gt; synchronousMethodHandlerFactory =</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">SynchronousMethodHandler</span>.Factory(client, retryer, requestInterceptors,</span><br><span class="line">          responseInterceptor, logger, logLevel, dismiss404, closeAfterDecode,</span><br><span class="line">          propagationPolicy, options, decoder, errorDecoder);</span><br><span class="line">  ParseHandlersByName&lt;Object&gt; handlersByName =</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">ParseHandlersByName</span>&lt;&gt;(contract, encoder, queryMapEncoder,</span><br><span class="line">          synchronousMethodHandlerFactory);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReflectiveFeign</span>&lt;&gt;(handlersByName, invocationHandlerFactory, () -&gt; <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>构建了一个ReflectiveFeign，然后调用ReflectiveFeign的newInstance方法，传入target，也就是前面传入的HardCodedTarget</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">newInstance</span><span class="params">(Target&lt;T&gt; target, C requestContext)</span> &#123;</span><br><span class="line">TargetSpecificationVerifier.verify(target);</span><br><span class="line"></span><br><span class="line">Map&lt;Method, MethodHandler&gt; methodToHandler =</span><br><span class="line">    targetToHandlersByName.apply(target, requestContext);</span><br><span class="line"><span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> factory.create(target, methodToHandler);</span><br><span class="line"><span class="type">T</span> <span class="variable">proxy</span> <span class="operator">=</span> (T) Proxy.newProxyInstance(target.type().getClassLoader(),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123;target.type()&#125;, handler);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (MethodHandler methodHandler : methodToHandler.values()) &#123;</span><br><span class="line">  <span class="keyword">if</span> (methodHandler <span class="keyword">instanceof</span> DefaultMethodHandler) &#123;</span><br><span class="line">    ((DefaultMethodHandler) methodHandler).bindTo(proxy);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法解释一下做了什么，首先 <code>targetToHandlersByName.apply</code> 通过target拿到client接口类型，去遍历接口内所有的方法，然后通过 <code>Contract</code> 解析所有方法注解封装成 <code>MethodMetadata</code> ，然后根据 <code>MethodMetadata</code> 等生成 <code>MethodHandler</code> ，返回的map的key就是方法，值为该方法的处理器，处理器里有该方法解析好的 <code>RequestTemplate</code> 等</p>
<blockquote>
<p>Contract 主要是用来解析方法上的注解的 默认是 SpringMvcContract，所以能支持MVC的注解</p>
</blockquote>
<p>后面就通过 <code>InvocationHandlerFactory</code> ，获取到一个InvocationHandler，之后通过jdk的动态代理，生成一个代理对象，InvocationHandler默认是 <code>ReflectiveFeign.FeignInvocationHandler</code>，在 <code>FeignInvocationHandler#invoke</code> 方法中会根据方法获取对应MethodHandler，具体的请求逻辑就在其invoke方法中，方法处理器有同步/异步请求等</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> InvocationHandler <span class="title function_">create</span><span class="params">(Target target, Map&lt;Method, MethodHandler&gt; dispatch)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReflectiveFeign</span>.FeignInvocationHandler(target, dispatch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FeignInvocationHandler(Target target, Map&lt;Method, MethodHandler&gt; dispatch) &#123;</span><br><span class="line">  <span class="built_in">this</span>.target = checkNotNull(target, <span class="string">&quot;target&quot;</span>);</span><br><span class="line">  <span class="built_in">this</span>.dispatch = checkNotNull(dispatch, <span class="string">&quot;dispatch for %s&quot;</span>, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FeignInvocationHandler#invoke</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&quot;equals&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">Object</span> <span class="variable">otherHandler</span> <span class="operator">=</span></span><br><span class="line">          args.length &gt; <span class="number">0</span> &amp;&amp; args[<span class="number">0</span>] != <span class="literal">null</span> ? Proxy.getInvocationHandler(args[<span class="number">0</span>]) : <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">return</span> equals(otherHandler);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;hashCode&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">    <span class="keyword">return</span> hashCode();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;toString&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">    <span class="keyword">return</span> toString();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dispatch.get(method).invoke(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="https://ddmcc-1255635056.file.myqcloud.com/060a59aa-6a36-480b-a856-d979f9bd8364.png"></p>
<h2 id="实现侧"><a href="#实现侧" class="headerlink" title="实现侧"></a>实现侧</h2><p>开头说实现侧和 <strong>普通controller类似，将这些方法封装成一个个handle并注册到handleMapping中，等待被DispatcherServlet调用</strong> ，经过上面对 <code>@FeignClient</code> 注解的分析，发现并没有关于接口这块处理。那是怎么被识别为 <code>Controller</code> 接口的呢？</p>
<p><strong>先来回顾一下怎么定义接口：</strong></p>
<ul>
<li>首先定义feign接口类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = AppConfig.APP_NAME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ICompanyClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">API_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;/client/company&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(API_PREFIX + &quot;/find-by-id/&#123;id&#125;&quot;)</span></span><br><span class="line">    R&lt;CompanyApiVo&gt; <span class="title function_">findById</span><span class="params">(<span class="meta">@PathVariable</span> String id)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般feign接口会单独放在一个jar包中，接口实现和调用方分别引入该jar包</p>
<ul>
<li>实现feign接口</li>
</ul>
<p>现在接口定义已经被单独放在了一个jar中了，在具体实现的包中引入它，然后编写具体实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor(onConstructor = @__(@Autowired))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompanyClientImpl</span> <span class="keyword">implements</span> <span class="title class_">ICompanyClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ICompanyService companyService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> R&lt;CompanyApiVo&gt; <span class="title function_">findById</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Company</span> <span class="variable">company</span> <span class="operator">=</span> companyService.findById(id);</span><br><span class="line">        <span class="keyword">return</span> R.data(CompanyConverter.INSTANCE.toCompanyApiVo(company));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>嗯。。。实际上这些方法能被识别并封装成一个个handle注册到handleMapping中，是因为实现类上加上了 <code>@RestController</code> 注解。在解析方法的时候又通过 <code>findMergedAnnotation</code> 获取方法的注解，所以标记在父类方法上的 <code>@xxxMapping</code> 也能获取到</p>
</div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/OpenFeign/">OpenFeign</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2023/05/29/2023-05-29-websocket-clusters/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">websocket服务集群搭建与消息收发实现</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2023/04/01/2023-04-01-composite-pattern/"><span class="level-item">设计模式之组合模式</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "8da48831f8c3e306c32ba752fd2ede3a",
            repo: "ddmcc.github.io",
            owner: "ddmcc",
            clientID: "dae41ffb8c8e11287ad0",
            clientSecret: "2e2acba40e8060cbac419bae13b068ab92a539ab",
            admin: ["ddmcc"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 20,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            language: "zh-CN",
        })
        gitalk.render('comment-container')</script></div></div></div><!--!--><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen  order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#前言"><span class="level-left"><span class="level-item">1</span><span class="level-item">前言</span></span></a></li><li><a class="level is-mobile" href="#调用侧"><span class="level-left"><span class="level-item">2</span><span class="level-item">调用侧</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#扫描-FeignClient注解类"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">扫描@FeignClient注解类</span></span></a></li><li><a class="level is-mobile" href="#生成动态代理对象"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">生成动态代理对象</span></span></a></li><li><a class="level is-mobile" href="#总结"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">总结</span></span></a></li></ul></li><li><a class="level is-mobile" href="#实现侧"><span class="level-left"><span class="level-item">3</span><span class="level-item">实现侧</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-07-06T07:34:00.000Z">2023-07-06</time></p><p class="title"><a href="/2023/07/06/2023-07-06-feign-integrates-ribbon/">feign基于ribbon实现负载均衡</a></p><p class="categories"><a href="/categories/Spring-Cloud/">Spring Cloud</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-05-29T07:34:00.000Z">2023-05-29</time></p><p class="title"><a href="/2023/05/29/2023-05-29-ribbon-components-and-integration-of-gateway/">openFeign整合ribbon实现负载均衡</a></p><p class="categories"><a href="/categories/Spring-Cloud/">Spring Cloud</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-05-29T07:34:00.000Z">2023-05-29</time></p><p class="title"><a href="/2023/05/29/2023-05-29-websocket-clusters/">websocket服务集群搭建与消息收发实现</a></p><p class="categories"><a href="/categories/websocket/">websocket</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-04-13T07:34:00.000Z">2023-04-13</time></p><p class="title"><a href="/2023/04/13/2023-04-13-how-feign-works/">OpenFeign的实现原理</a></p><p class="categories"><a href="/categories/Spring-Cloud/">Spring Cloud</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-04-01T07:34:00.000Z">2023-04-01</time></p><p class="title"><a href="/2023/04/01/2023-04-01-composite-pattern/">设计模式之组合模式</a></p><p class="categories"><a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></p></div></article></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">jiangrz</a><p class="is-size-7"><span>&copy; 2024 jiangrz</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent " target="_blank" rel="noopener" title="备案号：闽ICP备2023008580号-1" href="https://beian.miit.gov.cn">备案号：闽ICP备2023008580号-1</a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>